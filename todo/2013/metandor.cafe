-- specification and proof score for QLOCK with 
-- 'stateAsSetOfObservers+transOTS+GENcases'
--  with [NxState < State]  by KF130627

-- ===============================================
-- ========== System Specification ===============
-- ===============================================

-- labels for indicating status of each agent
mod! LABEL {
-- literal labels and labels
[LabelLt < Label]
-- rs: remainder section
-- ws: waiting section
-- cs: critical section
ops rs ws cs : -> LabelLt {constr} .
eq (L1:LabelLt = L2:LabelLt) = (L1 == L2) .
}

-- agent identifiers
mod* AID {[Aid]}

-- queue (First In First Out storage)
-- for storing agent identifiers
mod! QUEUE (X :: TRIV) {
-- elements and their queues
[Elt < Qu]
-- empty queue
op empQ : -> Qu {constr} . 
-- assoicative queue constructor with id: empQ
op (_&_) : Qu Qu -> Qu {constr assoc id: empQ} .
-- equality _=_ over Qu
eq (empQ = (E:Elt & Q:Qu)) = false .
ceq ((E1:Elt & Q1:Qu) = (E2:Elt & Q2:Qu)) 
    = ((E1 = E2) and (Q1 = Q2))
    if not((Q1 = empQ) and (Q2 = empQ)) .
-- head
op hd_ : Qu -> Elt .
eq hd(E:Elt & Q:Qu) = E .
-- hd(empQ) is not defined intentionally
-- a nice error handling method
-- tail
op tl_ : Qu -> Qu .
eq tl(E:Elt & Q:Qu) = Q .
-- tl(empQ) is not defined intentionally
-- a nice error handling method
}

-- observers
mod! OBS {
pr(LABEL)
pr(QUEUE(AID{sort Elt -> Aid}))
-- there are two kinds of obserbers
[Obs]
op (qu:_ ) : Qu -> Obs {constr} .
op (lb[_]:_) : Aid Label -> Obs {constr} .
}

-- generic set 
mod! SET(X :: TRIV) {
  [Elt.X < Set]
  op empty : -> Set {constr} .
  op _ _ : Set Set -> Set 
            {constr assoc comm id: empty} .
  -- idempotency
  eq E:Elt E = E .
}

-- a state is defined as a set of observers
mod! STATE {pr(SET(OBS{sort Elt -> Obs})
               *{sort Set -> State})}

"{{
-- ===============================================
Terms of the sort State

Ill-Formed:
(empty)
(qu: Q:Qu)
((qu: Q1:Qu)(qu: Q2:Qu))
(ld[A:Aid] L:Label)
((ld[A1:Aid] L1:Label)(ld[A2:Aid] L2:Label))

Well-Formed:
((qu: Q:Qu)(ld[A:Aid] L:Label) S:State)
((qu: Q1:Qu)(qu: Q2:Qu)(ld[A:Aid] L:Label) S:State)
((qu: Q1:Qu)(ld[A:Aid] L1:Label)
            (ld[A:Aid] L2:Label) S:State)
-- ===============================================
}}"

-- ===============================================
-- elementary functions on states 
mod! STATEfuns {
pr(NAT + STATE)  
-- variable declarations
vars L1 L2 : Label .
vars A1 A2 : Aid .
var S : State .
var Q : Qu .
-- the number of queues in a state
op #q : State -> Nat .
eq #q(empty) = 0 .
eq #q((qu: Q) S) = 1 + #q(S) .
eq #q((lb[A1]: L1) S) = #q(S) .
-- the number of labels in a state
op #ls : State Label -> Nat .
eq #ls(empty,L1) = 0 .
eq #ls(((qu: Q) S),L1) = #ls(S,L1) .
eq #ls(((lb[A1]: L1) S),L2) = 
   if (L1 = L2) then 1 + #ls(S,L2) 
   else #ls(S,L2) fi .
-- the number of aids in a state
op #as : State Aid -> Nat .
eq #as(empty,A1) = 0 .
eq #as((qu: Q) S,A1) = #as(S,A1) .
eq #as(((lb[A1]: L1) S),A2) = 
   if (A1 = A2) then 1 + #as(S,A2) 
   else #as(S,A2) fi .
-- the number of aids in a queue
op #aq : Qu Aid -> Nat .
eq #aq(empQ,A1) = 0 .
eq #aq(A1 & Q,A2) =
   if (A1 = A2) then 1 + #aq(Q,A2) 
   else #aq(Q,A2) fi .
}

-- names of predicates on states 
-- and conjunction of the predicates
mod! PNAMEcj {
pr(STATE)
-- names of predicates on States 
-- and sequences of them
[Pname < PnameSeq]
op (_ _) : PnameSeq PnameSeq -> PnameSeq {assoc} .
-- conjunction of predicates indicated in PnameSeq
op cj : PnameSeq State -> Bool .
eq cj(PN:Pname PNS:PnameSeq,S:State)
   = cj(PN,S) and cj(PNS,S) .
}

-- properties on states
-- for defining well formed states 
-- and initial state condition
mod! STATEprop {
pr(STATEfuns)
ex(PNAMEcj)

-- one queue in a state
op 1q : -> Pname .
eq[1q]: cj(1q,S:State) = (#q(S) = 1) .

-- no duplication of Aid in a state 
-- for an arbitrary Aid
op 1a : -> Pname .
eq[1a-1]: cj(1a,empty) = true .
eq[1a-2]: cj(1a,((lb[A:Aid]: L:Label) S:State)) 
          = (#as(S,A) = 0) and cj(1a,S) .
eq[1a-3]: cj(1a,((qu: Q:Qu) S:State)) =  cj(1a,S) .

-- qas pattern, only the state with this pattern 
-- needs to be considered
pred qas : State .
eq qas((qu: Q:Qu)(lb[A:Aid]: L:Label) S:State) 
   = true .
op qas : -> Pname .
eq[qas]: cj(qas,S:State) = 
    if (qas(S) == true) then true else false fi .

-- well formed states
op wfs : -> Pname .
eq wfs = qas 1q 1a .
-- notice that only the state s 
-- with (cj(wfs,s) = true) 
-- represents a meaningful state

-- the following two properties 
-- are for defining initial condition
-- queue is empy
op qe : -> Pname .
eq[qe1]: cj(qe,empty) = false .
eq[qe2]: cj(qe,((lb[A:Aid]: L:Label) S:State)) 
         = (#q(S) = 1) and cj(qe,S) .
eq[qe3]: cj(qe,((qu: Q:Qu) S:State)) 
         = (Q = empQ) and (#q(S) = 0) .
-- any Aid is in rs, i.e. no ws, no cs
op allRs : -> Pname .
eq[allRs]: cj(allRs,S:State) 
           = (#ls(S,ws) = 0) and (#ls(S,cs) = 0) .

}

-- ===============================================
-- QLOCK 
--  (mutual exclusion protocol with queue of aids) 
-- defined as transOTS
--  (observational transition system)
mod! QLOCK {
pr(STATEprop)
-- variables
var Q : Qu .
var L : Label .
vars A1 A2 : Aid .
var S : State .

-- initial state condition
op init : -> PnameSeq .
eq init = wfs qe allRs .
pred init : State .
eq init(S) = cj(init,S) .

-- next state
[NxState < State]
op nx_ : State -> NxState .
-- transitions defined by rewrite rules
-- wt : want
trans[wt]: 
     nx((qu: Q)(lb[A1]: rs) S) 
     => ((qu: (Q & A1))(lb[A1]: ws) S) .
-- ty : try
trans[ty]: 
     nx((qu: (A1 & Q))(lb[A2]: ws) S) 
     => if (A1 = A2) 
         then ((qu: (A1 & Q))(lb[A2]: cs) S)
         else ((qu: (A1 & Q))(lb[A2]: ws) S)
        fi .
-- ex: exit
trans[ex]: 
     nx((qu: (A2 & Q))(lb[A1]: cs) S) 
     => ((qu: Q)(lb[A1]: rs) S) .
}

-- ===============================================
-- ========== Property Specification =============
-- ========= (Invariant Specification) ===========
-- ===============================================

-- several properties on QLOCK and 
-- an invariant property of QLOCK
mod! QLOCKprop {
pr(QLOCK)
-- variable declarations
var L : Label . var A : Aid .
var S : State . var Q : Qu .
-- mutual exclusion property: 
-- at most one agent is with the label cs
op mx : -> Pname .
eq[mx]: cj(mx,S) 
        = ((#ls(S,cs) = 0) or (#ls(S,cs) = 1)) .
-- several fragment predicates for invariant
ops qep rs ws cs : -> Pname .

"
eq[qep]: cj(qep,((qu: Q)(lb[A]: L) S)) 
         = ((Q = empQ) implies 
            ((#ls(((lb[A]: L) S),cs) = 0) and
             (#ls(((lb[A]: L) S),ws) = 0))) .
($ | i(false,(((b1 & q) , b1) , (cs , (s , (QQ , (AA , LL))))))):IndTr
"
eq[:m-and qep]: cj(qep,((qu: Q)(lb[A]: L) S)) 
         = ((Q = empQ) implies (#ls(((lb[A]: L) S),cs) = 0)) .

eq[:m-and rs]: cj(rs,((qu: Q)(lb[A]: L) S)) 
        = ((L = rs) implies (#aq(Q,A) = 0)) .
eq[:m-and ws]: cj(ws,((qu: Q)(lb[A]: L) S)) 
        = ((L = ws) implies 
          ((#aq(Q,A) = 1) and
           ((A = hd(Q)) implies 
            (#ls(S,cs) = 0)))) .
eq[:m-and cs]: cj(cs,((qu: Q)(lb[A]: L) S)) 
        = ((L = cs) implies 
            ((A = hd(Q)) 
             and (#aq(tl(Q),A) = 0)
             and (#ls(S,cs) = 0))) .
-- invariant predicate
op inv : -> PnameSeq .
eq inv = wfs mx qep rs ws cs .
pred inv : State .
eq inv(S) = cj(inv,S) .
}

-- ===============================================
-- ============ Proof Score ======================
-- ===============================================

-- the following two modules describe 
-- the algorithm for generating a finite set 
-- of patterns that cover all possbile cases

-- predicate v that is to be checked
mod* PREDtbC {
-- values and their sequences
[Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- predicate to be checed
pred v : ValSq .
}

-- generating a finit set of patterns
-- that cover all possible combinations
-- of values in a value sequence
mod! GENcases (X :: PREDtbC) {
-- sequences of values for expansions
[Val < VlSq]
op _;_ : VlSq VlSq -> VlSq {assoc} .
-- sequence of ValSeq or VlSeq
[ValSq VlSq < SqSq]
op _,_ : SqSq SqSq -> SqSq {assoc} .
-- SqSq enclosures and their trees
[SqSqEn < SqSqTr]
op [_] : SqSq -> SqSqEn .
op _||_ : SqSqTr SqSqTr -> SqSqTr .

-- expanding (_;_) into (_||_)
var V : Val . 
var VS : VlSq . 
vars SS1 SS2 : SqSq .
eq [((V;VS),SS2)] = [(V,SS2)] || [(VS,SS2)] .
eq [(SS1,(V;VS),SS2)] 
   = [(SS1,V,SS2)] || [(SS1,VS,SS2)] .
eq [(SS1,(V;VS))] = [(SS1,V)] || [(SS1,VS)] .

-- indicators and their trees
[Ind < IndTr]
op $ : -> Ind .
op _|_ : IndTr IndTr -> IndTr .
-- indicator constructor
op i : Bool ValSq -> Ind {constr} .
-- compose indicator from (v : ValSq -> Bool)
-- that comes from (X :: PREDtbC)
op mi_ : ValSq -> Ind .
eq mi(VSQ:ValSq) = i(v(VSQ),VSQ) .

-- make make indicators (mmi):
-- translating a tree of SqSq (SqSqTr)
-- into a tree of indicators
op mmi_ : SqSqTr -> IndTr .
eq mmi(SST1:SqSqTr || SST2:SqSqTr) 
   = (mmi SST1) | (mmi SST2) .
-- if all _;_ in SqSq disappear
-- then translate mmi to mi
eq mmi[VSQ:ValSq] = mi(VSQ) .

-- making all indicators with "true" disappear 
eq i(true,VSQ:ValSq) | IT:IndTr = IT .
eq IT:IndTr | i(true,VSQ:ValSq) = IT .
}

-- ===============================================
-- facts to be used, 
-- this part changes according to modification 
-- of spec and proof score
mod FACTtbu {
pr(QLOCKprop)
-- necessary facts about _=_ on Nat
var N : Nat .
eq (1 = 0) = false .
eq ((1 + N) = 0) = false .
eq ((2 + N) = 0) = false .
eq ((2 + N) = 1) = false .
eq (1 + N = 1) = (N = 0) .
eq ((N = 0) and (N = 1)) = false .

-- necessary fact about #aq
eq #aq(Q:Qu & A1:Aid,A2:Aid) =
   if (A1 = A2) then 1 + #aq(Q,A2) 
   else #aq(Q,A2) fi .
}
-- ===============================================

-- ===============================================
-- Verification of the Initial State Condition

--> [0] cj(wfs,s) = false .
open QLOCKprop .
op s : -> State .
eq cj(wfs,s) = false .
red init(s) implies inv(s) .
close

--> [1] cj(wfs,s) = true .
-- define v for initial condition
mod QLOCKinit {
pr(QLOCKprop)
[Qu Aid Label State < Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- prePreds : predicates for premise
-- conPreds : predicates for conclusion
ops prePreds conPreds : -> PnameSeq .
-- predicate to be checked
op v : ValSq -> Bool .
eq v(Q:Qu,A:Aid,L:Label,S:State) 
   = cj(prePreds,((qu: Q)(lb[A]: L) S)) 
      implies cj(conPreds,((qu: Q)(lb[A]: L) S)) .
}
-- generate and check all possible cases 
-- for initial condition
mod CKallCasesInit {
ex(GENcases(QLOCKinit))
-- Aid constant literals
[AidConLt < Aid]
eq (B1:AidConLt = B2:AidConLt) = (B1 == B2) .
-- arbitray (ordinary or literal) constants
ops b1 b2 : -> AidConLt .
op q : -> Qu .
op s : -> State .
op ck : -> IndTr .
-- a term of sort IndTr 
-- for checking all possible cases
eq ck = ($ | mmi[(empQ;(b1 & q)),
                 (b1;b2),
                 (rs;ws;cs),
                 (s)]) .
}
-- reduction for verification 
-- of initial state condition
open CKallCasesInit .
pr(FACTtbu)
eq prePreds = init .
eq conPreds = inv .
red ck .
close

"{{
-- ===============================================
[(empQ;(b1 & q)),
 (b1;b2),
 (rs;ws;cs),
 (s)]

generates a finite set of patterns that cover all 
ground terms that are instances of the following
term (sequence of variables)

(Q:Qu,A:Aid,L:Label,S:State) 
-- ===============================================
}}"

-- ===============================================
-- Verification of the Invariant Condition

--> [0] cj(wfs,s) = false .
-- the following proof score is not correct because
-- there is no T such that (s =(*,1)=>+ T) trivially
-- from the transition definitions by rules
open QLOCKprop .
op s : -> State .
var T : State .
eq cj(wfs,s) = false .
red (not((nx s) =(*,1)=>+ T)
     implies
     (cj(inv,s) implies cj(inv,(nx s))))
    and
    (not((nx s) =(*,1)=>+ T
         suchThat
         (not((cj(inv,s) implies cj(inv,T))
               == true)))) .
close

-- to guarantee the covering of all cases require
-- subtle discussions, need to check!! 130625
--> [1] cj(wfs,s) = true .
-- define v for invariant condition
mod QLOCKinv {
pr(QLOCKprop)
-- val and ValSeq
[Qu Aid Label State Tname < Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- prePreds : predicates for pre-condition
-- postPreds : predicates for post-condition
ops prePreds postPreds : -> PnameSeq .
-- predicate to be checked
ops v v1 v2 : ValSq -> Bool .
eq v(Q:Qu,A:Aid,L:Label,S:State,QQ:Qu,AA:Aid,LL:Label) =
    ((not(nx((qu: Q) (lb[A]: L) S) 
          =(*,1)=>+ 
         ((qu: QQ) (lb[AA]: LL) S)))
       implies
     (cj(prePreds,((qu: Q) (lb[A]: L) S))
      implies 
      cj(postPreds,nx(((qu: Q) (lb[A]: L) S)))))
    and 
    (not(nx((qu: Q) (lb[A]: L) S) 
         =(*,1)=>+ 
         ((qu: QQ) (lb[AA]: LL) S)
         suchThat
         (not((cj(prePreds,((qu: Q) (lb[A]: L) S))
               implies 
               cj(postPreds,((qu: QQ) (lb[AA]: LL) S)))
                == true)))) .

eq v1(Q:Qu,A:Aid,L:Label,S:State,QQ:Qu,AA:Aid,LL:Label) =
    ((not(nx((qu: Q) (lb[A]: L) S) 
          =(*,1)=>+ 
         ((qu: QQ) (lb[AA]: LL) S)))
       implies
     (cj(prePreds,((qu: Q) (lb[A]: L) S))
      implies 
      cj(postPreds,nx(((qu: Q) (lb[A]: L) S))))) .

eq v2(Q:Qu,A:Aid,L:Label,S:State,QQ:Qu,AA:Aid,LL:Label) =
    (not(nx((qu: Q) (lb[A]: L) S) 
         =(*,1)=>+ 
         ((qu: QQ) (lb[AA]: LL) S)
         suchThat
         (not((cj(prePreds,((qu: Q) (lb[A]: L) S))
               implies 
               cj(postPreds,((qu: QQ) (lb[AA]: LL) S)))
                == true)))) .

}

-- generate and check all possible cases for
mod CKallCasesInv {
ex(GENcases(QLOCKinv))
-- Aid constant literals
[AidConLt < Aid]
eq (B1:AidConLt = B2:AidConLt) = (B1 == B2) .
-- 
op ck : Qu Aid Label -> IndTr .
-- variables to be bound by predicate (_=(*,1)=>+_) 
var QQ : Qu .
var AA : Aid .
var LL : Label .
-- arbitray (ordinary or literal) constants
ops b1 b2 : -> AidConLt .
op q : -> Qu .
op s : -> State .
-- 
eq ck(QQ,AA,LL) = 
    ($ | mmi[(empQ;(b1 & q)),
             (b1;b2),
             (rs;ws;cs),
             (s),
             (QQ),(AA),(LL)]) .
}
-- reduction for verification 
-- of invariant condition
open CKallCasesInv .
pr(FACTtbu)
eq prePreds = inv .
eq postPreds = inv .
red ck(QQ,AA,LL) .
close

"{{
-- ===============================================
[(empQ;(b1 & q)),
             (b1;b2),
             (rs;ws;cs),
             (s),
             (QQ),(AA),(LL)]

generates a finite set of patterns that cover all 
ground terms that are instances of the following
term (sequence of variables)

(Q:Qu,A:Aid,L:Label,S:State,QQ:Qu,AA:Aid,LL:Label)
-- ===============================================
}}"

eof
