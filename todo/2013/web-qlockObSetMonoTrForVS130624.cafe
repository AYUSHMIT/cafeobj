-- specification and proof score for QLOCK with 
-- 'stateAsSetOfObservers+monoActionOTS+GENcases'
-- significantly improved after 130620Vsemi
-- and discussion with K.Ogata 
-- by KF130623

-- ===============================================
-- ========== System Specification ===============
-- ===============================================

-- labels for indicating status of each agent
mod! LABEL {
-- literal labels and labels
[LabelLt < Label]
-- rs: remainder section
-- ws: waiting section
-- cs: critical section
ops rs ws cs : -> LabelLt {constr} .
eq (L1:LabelLt = L2:LabelLt) = (L1 == L2) .
}

-- agent identifiers
mod* AID {[Aid]}

-- queue (First In First Out storage)
-- for storing agent identifiers
mod! QUEUE (X :: TRIV) {
-- elements and their queues
[Elt < Qu]
-- empty queue
op empQ : -> Qu {constr} . 
-- assoicative queue constructor with id: empQ
op (_&_) : Qu Qu -> Qu {constr assoc id: empQ} .
-- equality _=_ over Qu
eq (empQ = (E:Elt & Q:Qu)) = false .
ceq ((E1:Elt & Q1:Qu) = (E2:Elt & Q2:Qu)) 
    = ((E1 = E2) and (Q1 = Q2))
    if not((Q1 = empQ) and (Q2 = empQ)) .
-- head
op hd_ : Qu -> Elt .
eq hd(E:Elt & Q:Qu) = E .
-- hd(empQ) is not defined intentionally
-- a nice error handling method
-- tail
op tl_ : Qu -> Qu .
eq tl(E:Elt & Q:Qu) = Q .
-- tl(empQ) is not defined intentionally
-- a nice error handling method
}

-- observers
mod! OBS {
pr(LABEL)
pr(QUEUE(AID{sort Elt -> Aid}))
-- there are two kinds of obserbers
[Obs]
op (qu:_ ) : Qu -> Obs {constr} .
op (lb[_]:_) : Aid Label -> Obs {constr} .
}

-- generic set 
mod! SET(X :: TRIV) {
  [Elt.X < Set]
  op empty : -> Set {constr} .
  op _ _ : Set Set -> Set 
            {constr assoc comm id: empty} .
  -- idempotency
  eq E:Elt E = E .
}

-- a state is defined as a set of observers
mod! STATE {pr(SET(OBS{sort Elt -> Obs})
               *{sort Set -> State})}

"{{
-- ===============================================
Terms of the sort State

Ill-Formed:
(empty)
(qu: Q:Qu)
((qu: Q1:Qu)(qu: Q2:Qu))
(ld[A:Aid] L:Label)
((ld[A1:Aid] L1:Label)(ld[A2:Aid] L2:Label))

Well-Formed:
((qu: Q:Qu)(ld[A:Aid] L:Label) S:State)
((qu: Q1:Qu)(qu: Q2:Qu)(ld[A:Aid] L:Label) S:State)
((qu: Q1:Qu)(ld[A:Aid] L1:Label)
            (ld[A:Aid] L2:Label) S:State)
-- ===============================================
}}"

-- ===============================================
-- elementary functions on states 
mod! STATEfuns {
pr(NAT + STATE)  
-- variable declarations
vars L1 L2 : Label .
vars A1 A2 : Aid .
var S : State .
var Q : Qu .
-- the number of queues in a state
op #q : State -> Nat .
eq #q(empty) = 0 .
eq #q((qu: Q) S) = 1 + #q(S) .
eq #q((lb[A1]: L1) S) = #q(S) .
-- the number of labels in a state
op #ls : State Label -> Nat .
eq #ls(empty,L1) = 0 .
eq #ls(((qu: Q) S),L1) = #ls(S,L1) .
eq #ls(((lb[A1]: L1) S),L2) = 
   if (L1 = L2) then 1 + #ls(S,L2) 
   else #ls(S,L2) fi .
-- the number of aids in a state
op #as : State Aid -> Nat .
eq #as(empty,A1) = 0 .
eq #as((qu: Q) S,A1) = #as(S,A1) .
eq #as(((lb[A1]: L1) S),A2) = 
   if (A1 = A2) then 1 + #as(S,A2) 
   else #as(S,A2) fi .
-- the number of aids in a queue
op #aq : Qu Aid -> Nat .
eq #aq(empQ,A1) = 0 .
eq #aq(A1 & Q,A2) =
   if (A1 = A2) then 1 + #aq(Q,A2) 
   else #aq(Q,A2) fi .
}

-- names of predicates on states 
-- and conjunction of the predicates
mod! PNAMEcj {
pr(STATE)
-- names of predicates on States 
-- and sequences of them
[Pname < PnameSeq]
op (_ _) : PnameSeq PnameSeq -> PnameSeq {assoc} .
-- conjunction of predicates indicated in PnameSeq
op cj : PnameSeq State -> Bool .
eq cj(PN:Pname PNS:PnameSeq,S:State)
   = cj(PN,S) and cj(PNS,S) .
}

-- properties on states
-- for defining well formed states 
-- and initial state condition
mod! STATEprop {
pr(STATEfuns)
ex(PNAMEcj)

-- one queue in a state
op 1q : -> Pname .
eq[1q]: cj(1q,S:State) = (#q(S) = 1) .

-- no duplication of Aid in a state 
-- for an arbitrary Aid
op 1a : -> Pname .
eq[1a-1]: cj(1a,empty) = true .
eq[1a-2]: cj(1a,((lb[A:Aid]: L:Label) S:State)) 
          = (#as(S,A) = 0) and cj(1a,S) .
eq[1a-3]: cj(1a,((qu: Q:Qu) S:State)) =  cj(1a,S) .

-- qas pattern, only the state with this pattern 
-- needs to be considered
pred qas : State .
eq qas((qu: Q:Qu)(lb[A:Aid]: L:Label) S:State) 
   = true .
op qas : -> Pname .
eq[qas]: cj(qas,S:State) = 
    if (qas(S) == true) then true else false fi .

-- well formed states
op wfs : -> Pname .
eq wfs = qas 1q 1a .
-- notice that only the state s 
-- with (cj(wfs,s) = true) 
-- represents a meaningful state

-- the following two properties 
-- are for defining initial condition
-- queue is empy
op qe : -> Pname .
eq[qe1]: cj(qe,empty) = false .
eq[qe2]: cj(qe,((lb[A:Aid]: L:Label) S:State)) 
         = (#q(S) = 1) and cj(qe,S) .
eq[qe3]: cj(qe,((qu: Q:Qu) S:State)) 
         = (Q = empQ) and (#q(S) = 0) .
-- any Aid is in rs, i.e. no ws, no cs
op allRs : -> Pname .
eq[allRs]: cj(allRs,S:State) 
           = (#ls(S,ws) = 0) and (#ls(S,cs) = 0) .

}

-- ===============================================
-- QLOCK 
--  (mutual exclusion protocol with queue of aids) 
-- defined as monoActionOTS
--  (observational transition system)
mod! QLOCK {
pr(STATEprop)
-- variables
var Q : Qu .
var L : Label .
vars A1 A2 A3 : Aid .
var S : State .

-- initial state condition
op init : -> PnameSeq .
eq init = wfs qe allRs .
pred init : State .
eq init(S) = cj(init,S) .

-- transitions and names of transitions
[Trans Tname]
-- want (wt), try (ty), and exit (ex)
ops wt ty ex : -> Tname .
-- transiton is product of tname and aid
op (_ _) : Tname Aid -> Trans {constr} .

-- definition of transitions
op tr : State Trans -> State .
** notice that the following definitions assume 
** (cj(wfs,((qu: Q)(lb[A1]: L) S)) = true) and
** (cj(wfs,((qu: (A1 & Q))(lb[A2]: L) S)) 
**  = true)
-- wt : wait
eq[wt]: tr(((qu: Q)(lb[A1]: L) S),(wt A2))
        = if ((L = rs) and (A1 = A2))
            then ((qu: (Q & A1))(lb[A1]: ws) S) 
            else ((qu: Q)(lb[A1]: L) S) 
          fi .
-- ty : try
eq[ty1]: tr(((qu: empQ)(lb[A1]: L) S),(ty A2)) 
         = ((qu: empQ)(lb[A1]: L) S) .
eq[ty2]: 
   tr(((qu: (A1 & Q))(lb[A2]: L) S),(ty A3)) 
   = if ((A1 = A2) and (A2 = A3) and (L = ws)) 
       then ((qu: (A1 & Q))(lb[A2]: cs) S)
       else ((qu: (A1 & Q))(lb[A2]: L) S) 
     fi .
-- ex : exit
eq[ex1]: tr(((qu: empQ)(lb[A1]: L) S),(ex A2)) 
         = ((qu: empQ)(lb[A1]: L) S) .
eq[ex2]: 
   tr(((qu: (A1 & Q))(lb[A2]: L) S),(ex A3))  
   = if ((A1 = A2) and (A2 = A3) and (L = cs)) 
       then ((qu: Q)(lb[A2]: rs) S)
       else ((qu: (A1 & Q))(lb[A2]: L) S) 
     fi .
}

-- ===============================================
-- ========== Property Specification =============
-- ========= (Invariant Specification) ===========
-- ===============================================

-- several properties on QLOCK and 
-- an invariant property of QLOCK
mod! QLOCKprop {
pr(QLOCK)
-- variable declarations
var L : Label . var A : Aid .
var S : State . var Q : Qu .
-- mutual exclusion property: 
-- at most one agent is with the label cs
op mx : -> Pname .
eq[mx]: cj(mx,S) 
        = ((#ls(S,cs) = 0) or (#ls(S,cs) = 1)) .
-- several fragment predicates for invariant
ops qep rs ws cs : -> Pname .
eq[qep]: cj(qep,((qu: Q)(lb[A]: L) S)) 
         = ((Q = empQ) implies 
            (#ls(((lb[A]: L) S),cs) = 0)) .
eq[rs]: cj(rs,((qu: Q)(lb[A]: L) S)) 
        = ((L = rs) implies (#aq(Q,A) = 0)) .
eq[ws]: cj(ws,((qu: Q)(lb[A]: L) S)) 
        = ((L = ws) implies 
          ((#aq(Q,A) = 1) and
           ((A = hd(Q)) implies 
            (#ls(S,cs) = 0)))) .
eq[cs]: cj(cs,((qu: Q)(lb[A]: L) S)) 
        = ((L = cs) implies 
            ((A = hd(Q)) 
             and (#aq(tl(Q),A) = 0)
             and (#ls(S,cs) = 0))) .
-- invariant predicate
op inv : -> PnameSeq .
eq inv = wfs mx qep rs ws cs .
pred inv : State .
eq inv(S) = cj(inv,S) .
}

-- ===============================================
-- ============ Proof Score ======================
-- ===============================================

-- the following two modules describe 
-- the algorithm for generating a finite set 
-- of patterns that cover all possbile cases

-- predicate v that is to be checked
mod* PREDtbC {
-- values and their sequences
[Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- predicate to be checed
pred v : ValSq .
}

-- generating a finit set of patterns
-- that cover all possible combinations
-- of values in a value sequence
mod! GENcases (X :: PREDtbC) {
-- sequences of values for expansions
[Val < VlSq]
op _;_ : VlSq VlSq -> VlSq {assoc} .
-- sequence of ValSeq or VlSeq
[ValSq VlSq < SqSq]
op _,_ : SqSq SqSq -> SqSq {assoc} .
-- SqSq enclosures and their trees
[SqSqEn < SqSqTr]
op [_] : SqSq -> SqSqEn .
op _||_ : SqSqTr SqSqTr -> SqSqTr .

-- expanding (_;_) into (_||_)
var V : Val . 
var VS : VlSq . 
vars SS1 SS2 : SqSq .
eq [((V;VS),SS2)] = [(V,SS2)] || [(VS,SS2)] .
eq [(SS1,(V;VS),SS2)] 
   = [(SS1,V,SS2)] || [(SS1,VS,SS2)] .
eq [(SS1,(V;VS))] = [(SS1,V)] || [(SS1,VS)] .

-- indicators and their trees
[Ind < IndTr]
op $ : -> Ind .
op _|_ : IndTr IndTr -> IndTr .
-- indicator constructor
op i : Bool ValSq -> Ind {constr} .
-- compose indicator from (v : ValSq -> Bool)
-- that comes from (X :: PREDtbC)
op mi_ : ValSq -> Ind .
eq mi(VSQ:ValSq) = i(v(VSQ),VSQ) .

-- make make indicators (mmi):
-- translating a tree of SqSq (SqSqTr)
-- into a tree of indicators
op mmi_ : SqSqTr -> IndTr .
eq mmi(SST1:SqSqTr || SST2:SqSqTr) 
   = (mmi SST1) | (mmi SST2) .
-- if all _;_ in SqSq disappear
-- then translate mmi to mi
eq mmi[VSQ:ValSq] = mi(VSQ) .

-- making all indicators with "true" disappear 
eq i(true,VSQ:ValSq) | IT:IndTr = IT .
eq IT:IndTr | i(true,VSQ:ValSq) = IT .
}

-- ===============================================
-- facts to be used, 
-- this part changes according to modification 
-- of spec and proof score
mod FACTtbu {
pr(QLOCKprop)
-- necessary facts about _=_ on Nat
var N : Nat .
eq (1 = 0) = false .
eq ((1 + N) = 0) = false .
eq ((2 + N) = 0) = false .
eq ((2 + N) = 1) = false .
eq (1 + N = 1) = (N = 0) .
eq ((N = 0) and (N = 1)) = false .

-- necessary fact about #aq
eq #aq(Q:Qu & A1:Aid,A2:Aid) =
   if (A1 = A2) then 1 + #aq(Q,A2) 
   else #aq(Q,A2) fi .
}
-- ===============================================

-- ===============================================
-- Verification of the Initial State Condition

--> [0] cj(wfs,s) = false .
open QLOCKprop .
op s : -> State .
eq cj(wfs,s) = false .
red init(s) implies inv(s) .
close

--> [1] cj(wfs,s) = true .
-- define v for initial condition
mod QLOCKinit {
pr(QLOCKprop)
[Qu Aid Label State < Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- prePreds : predicates for premise
-- conPreds : predicates for conclusion
ops prePreds conPreds : -> PnameSeq .
-- predicate to be checked
op v : ValSq -> Bool .
eq v(Q:Qu,A:Aid,L:Label,S:State) 
   = cj(prePreds,((qu: Q)(lb[A]: L) S)) 
      implies cj(conPreds,((qu: Q)(lb[A]: L) S)) .
}
-- generate and check all possible cases 
-- for initial condition
mod CKallCasesInit {
ex(GENcases(QLOCKinit))
-- Aid constant literals
[AidConLt < Aid]
eq (B1:AidConLt = B2:AidConLt) = (B1 == B2) .
-- arbitray (ordinary or literal) constants
ops b1 b2 : -> AidConLt .
op q : -> Qu .
op s : -> State .
op ck : -> IndTr .
-- a term of sort IndTr 
-- for checking all possible cases
eq ck = ($ | mmi[(empQ;(b1 & q)),
                 (b1;b2),
                 (rs;ws;cs),
                 (s)]) .
}
-- reduction for verification 
-- of initial state condition
open CKallCasesInit .
pr(FACTtbu)
eq prePreds = init .
eq conPreds = inv .
red ck .
close

"{{
-- ===============================================
[(empQ;(b1 & q)),
 (b1;b2),
 (rs;ws;cs),
 (s)]

generates a finite set of patterns that cover all 
ground terms that are instances of the following
term (sequence of variables)

(Q:Qu,A:Aid,L:Label,S:State) 
-- ===============================================
}}"

-- ===============================================
-- Verification of the Invariant Condition

--> [0] cj(wfs,s) = false .
open QLOCKprop .
op s : -> State .
op t : -> Trans .
eq cj(wfs,s) = false .
red inv(s) implies inv(tr(s,t)) .
close

--> [1] cj(wfs,s) = true .
-- define v for invariant condition
mod QLOCKinv {
pr(QLOCKprop)
-- val and ValSeq
[Qu Aid Label State Tname < Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .
-- prePreds : predicates for pre-condition
-- postPreds : predicates for post-condition
ops prePreds postPreds : -> PnameSeq .
-- predicate to be checked
op v : ValSq -> Bool .
eq v(Q:Qu,A1:Aid,L:Label,S:State,T:Tname,A2:Aid) 
   = cj(prePreds,((qu: Q)(lb[A1]: L) S)) 
     implies cj(postPreds,
                tr(((qu: Q)(lb[A1]: L) S),(T A2))) .
}
-- generate and check all possible cases for
-- invariant condition (162 cases)
mod CKallCasesInv {
ex(GENcases(QLOCKinv))
-- Aid constant literals
[AidConLt < Aid]
eq (B1:AidConLt = B2:AidConLt) = (B1 == B2) .
-- arbitray (ordinary or literal) constants
ops b1 b2 b3 : -> AidConLt .
op q : -> Qu .
op s : -> State .
op ck : -> IndTr .
eq ck = ($ | mmi[(empQ;(b1 & q)),
                 (b1;b2),
                 (rs;ws;cs),
                 (s),
                 (wt;ty;ex),
                 (b1;b2;b3)]) .
}
-- reduction for verification 
-- of invariant condition
open CKallCasesInv .
pr(FACTtbu)
eq prePreds = inv .
eq postPreds = inv .
red ck .
close

"{{
-- ===============================================
[(empQ;(b1 & q)),
 (b1;b2),
 (rs;ws;cs),
 (s),
 (wt;ty;ex),
 (b1;b2;b3)]) .

generates a finite set of patterns that cover all 
ground terms that are instances of the following
term (sequence of variables)

(Q:Qu,A1:Aid,L:Label,S:State,T:Tname,A2:Aid)
-- ===============================================
}}"

eof
