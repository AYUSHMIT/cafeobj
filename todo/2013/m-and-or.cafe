** ===============================================================
**   m-and/m-or(matching-and/matching-or) examples 
**   with qlock
**   KF131111
** ===============================================================

** ===============================================================
** ================ System Specification =========================
** ===============================================================

-- three labels for indicating status of each agent
mod! LABEL {
-- label literals and labels
[LabelLt < Label]
-- rs: remainder section
-- ws: waiting section
-- cs: critical section
ops rs ws cs : -> LabelLt {constr} .
-- vars L1 L2 : LabelLt .
eq (L1:LabelLt = L2:LabelLt) = (L1 == L2) .
}

-- agent identifiers
mod* AID {[Aid]}

-- ===============================================================
-- queue (first in first out storage)
mod! QUEUE (X :: TRIV) {
-- elements and their queues, Elt comes from (X :: TRIV)

[Elt.X < Qu]
-- empty queue
op empQ : -> Qu {constr} . 
-- assoicative queue constructors with id: empQ
op (_&_) : Qu Qu -> Qu {constr assoc id: empQ} .
-- equality _=_ over the sort Qu
eq (empQ = (E:Elt & Q:Qu)) = false .
ceq ((E1:Elt & Q1:Qu) = (E2:Elt & Q2:Qu)) 
    = ((E1 = E2) and (Q1 = Q2))
    if not((Q1 = empQ) and (Q2 = empQ)) .

-- error elements
[Elt.X < Elt&Err]
-- head
op hd_ : Qu -> Elt&Err .
eq hd(E:Elt & Q:Qu) = E .
-- hd(empQ):Elt&Err indicates an error element
-- and no equations for it; an error handling method

-- error queues
[Qu < Qu&Err]
-- tail
op tl_ : Qu -> Qu&Err .
eq tl(E:Elt & Q:Qu) = Q .
-- tl(empQ):Qu&Err indicates an error queue
-- and no equations for it; an error handling method
}

-- ===============================================================
-- observers
mod! OBS {
pr(LABEL) 
pr(QUEUE(AID{sort Elt -> Aid})*{sort Elt&Err -> Aid&Err})
-- there are two kinds of obserbers
[Obs]

-- (qu: Q:Queue) is a term of the sort Obs 
-- that indicates the current global queue is Q
op (qu:_ ) : Qu -> Obs {constr} .

-- (lb[A:Aid]: L:Label) is a term of the sort Obs 
-- (an observer) that indicates an agent A has a label L
op (lb[_]:_) : Aid Label -> Obs {constr} .
}

-- generic set 
mod! SET(X :: TRIV) {
[Elt.X < Set]
-- empty set
op empty : -> Set {constr} .
-- assicative and commutative set constructor with identity empty
op (_ _) : Set Set -> Set {constr assoc comm id: empty} .
-- (_ _) is idempotent with respect to the sort Elt
eq E:Elt E = E .
}

-- a state is defined as a set of observers
mod! STATE{pr(SET(OBS{sort Elt -> Obs})*{sort Set -> State})}

-- ===============================================================
-- wt: want transition
mod! WT {inc(STATE)
trans[wt]: 
     ((qu: Q:Qu)(lb[A:Aid]: rs) S:State) 
     => ((qu: (Q & A))(lb[A]: ws) S) . 
}
-- ty: try transition
mod! TY {inc(STATE)
trans[ty]: 
     ((qu: (A:Aid & Q:Qu))(lb[A]: ws) S:State) 
     => ((qu: (A & Q))(lb[A]: cs) S) .
}
-- ex: exit transition
mod! EX {inc(STATE)
trans[ex]: 
   ((qu: (A1:Aid & Q:Qu))(lb[A2:Aid]: cs) S:State) 
   => ((qu: Q)(lb[A2]: rs) S) .
}

-- ===============================================================
-- system specification of QLOCK
mod! QLOCKsys{pr(WT + TY + EX)}

** ===============================================================
** ================ Property Specification =======================
** ===============================================================

-- ===============================================================
-- for defining state predicates

-- Peano Style Natural Numbers with ac-_+_  and _>_
mod! PNAT+ac {
  [Nat]
  op 0 : -> Nat {constr} .
  op s_ : Nat -> Nat {constr} .
 -- equality over the natural numbers
  eq (0 = s(Y:Nat)) = false .
  eq (s(X:Nat) = s(Y:Nat)) = (X = Y) .
  -- associative and commutative _+_
  op _+_ : Nat Nat -> Nat {assoc comm} .
  eq 0 + Y:Nat = Y .
  eq (s X:Nat) + Y:Nat = s(X + Y) .
  -- greater than
  [Nat < Nat&Err]
  op _>_ : Nat&Err Nat&Err -> Bool .
  eq (s X:Nat) > 0 = true .
  eq 0 > (s Y:Nat) = false .
  eq (s X:Nat) > (s Y:Nat) = X > Y .
  eq (s X:Nat) > X = true .
  eq X:Nat > (s X) = false .
  eq X:Nat > X = false .
}

-- elementary functions on states 
mod! STATEfuns {pr(PNAT+ac + STATE) 
-- variable declarations
vars L1 L2 : Label . vars A1 A2 : Aid .
var S : State .  vars Q Q' : Qu .
-- the number of queues in a state
op #q : State -> Nat .
eq #q(empty) = 0 .
eq #q((qu: Q) S) = (s 0) + #q(S) .
eq #q((lb[A1]: L1) S) = #q(S) .
-- the queue in a state
op qu : State -> Qu&Err .
op qus : State -> Qu .
ceq qu(S) = qus(S) if (#q(S) = (s 0)) .
eq qus((qu: Q) S) = Q .
eq qus((lb[A1]: L1) S) = qus(S) .
-- the number of a label in a state
op #ls : State Label -> Nat .
eq #ls(empty,L1) = 0 .
eq #ls(((qu: Q) S),L1) = #ls(S,L1) .
eq #ls(((lb[A1]: L1) S),L2) = 
   if (L1 = L2) then (s 0) + #ls(S,L2) 
   else #ls(S,L2) fi .
-- the number of an aid in a state
op #as : State Aid -> Nat .
eq #as(empty,A1) = 0 .
eq #as((qu: Q) S,A1) = #as(S,A1) .
eq #as(((lb[A1]: L1) S),A2) = 
   if (A1 = A2) then (s 0) + #as(S,A2) 
   else #as(S,A2) fi .
-- the number of an aid in a queue
op #aq : Qu Aid -> Nat .
eq #aq(empQ,A1) = 0 .
eq #aq(A1 & Q,A2) =
   if (A1 = A2) then (s 0) + #aq(Q,A2) 
   else #aq(Q,A2) fi .
-- the depth of the first appearence 
-- of an aid in a queue
op #daq : Qu&Err Aid -> Nat&Err .
op #daq-sub : Qu Aid -> Nat .
ceq #daq(Q,A1) = #daq-sub(Q,A1) if not(#aq(Q,A1) = 0) .
eq #daq-sub(A1 & Q,A2) = 
   if (A1 = A2) then 0 else s(#daq-sub(Q,A2)) fi .
}

-- names of predicates on states and conjunction of the predicates
mod! PNAMEcj {pr(STATE)
-- names of predicates on States and sequences of them
[Pname < PnameSeq]
op (_ _) : PnameSeq PnameSeq -> PnameSeq {assoc} .
-- conjunction of predicates indicated in PnameSeq
op cj : PnameSeq State -> Bool .
eq cj(PN:Pname PNS:PnameSeq,S:State)
   = cj(PN,S) and cj(PNS,S) .
}

-- ===============================================================
-- predicates on states for well formed states and intitial states
mod! STATEpred1 {pr(STATEfuns)ex(PNAMEcj)
-- one queue in a state
op 1q : -> Pname .
eq[1q]: cj(1q,S:State) = (#q(S) = (s 0)) .
-- no duplication of an Aid in a state 
op 1a : -> Pname .
eq[1a]: cj(1a,empty) = true .
eq[1a]: cj(1a,((lb[A:Aid]: L:Label) S:State)) = 
        (#as(S,A) = 0) and cj(1a,S) .
eq[1a]: cj(1a,((qu: Q:Qu) S:State)) = cj(1a,S) .
-- qas pattern, only the state with this pattern is well formed
pred qas : State .
eq qas((qu: Q:Qu)(lb[A:Aid]: L:Label) S:State) = true .
op qas : -> Pname .
eq[qas]: cj(qas,S:State) = qas(S) .
-- well formed states
op wfs : -> Pname .
eq wfs = qas 1q 1a .
-- there is exactly one empty queue
op qe : -> Pname .
eq[qe]: cj(qe,empty) = false .
eq[qe]: cj(qe,((lb[A:Aid]: L:Label) S:State)) 
        = cj(qe,S) .
eq[qe]: cj(qe,((qu: Q:Qu) S:State)) 
        = (Q = empQ) and (#q(S) = 0) .
-- any Aid is in rs status, i.e. no ws, no cs
op allRs : -> Pname .
eq[allRs]: cj(allRs,S:State) = (#ls(S,ws)= 0) and (#ls(S,cs)= 0) .
}

-- ===============================================================
-- an initial state predicate
mod! INIT {pr(STATEpred1)
op init : -> PnameSeq .
eq init = wfs qe allRs .
-- initial state predicate
pred init : State .
eq init(S:State) = cj(init,S) .
}

-- ===============================================================
-- predicates on states for an inductive invariant predicate
mod! STATEpred2 {pr(STATEpred1)
-- variable declarations
var L : Label . var A : Aid .
var S : State . var Q : Qu .
-- mutual exclusion property: at most one agent is with cs
-- this is the goal predicate
op mx : -> Pname .
eq[mx]: cj(mx,S) = ((#ls(S,cs) = 0) or (#ls(S,cs) = (s 0))) .
-- several fragment predicates for an inductive invariant
ops qep rs ws cs : -> Pname .
-- if queue is empty
eq[:m-and qep]: cj(qep,((qu: Q)(lb[A]: L) S)) 
         = ((Q = empQ) implies 
            (#ls(((lb[A]: L) S),cs) = 0)) .
-- if agent is in rs
eq[:m-and rs]: cj(rs,((qu: Q)(lb[A]: L) S)) 
        = ((L = rs) implies (#aq(Q,A) = 0)) .
-- if agent is in ws
eq[:m-and ws]: cj(ws,((qu: Q)(lb[A]: L) S)) 
        = ((L = ws) implies 
           ((#aq(Q,A) = (s 0)) and
            ((A = hd(Q)) implies (#ls(S,cs) = 0)))) .
-- if agent is in cs
eq[:m-and cs]: cj(cs,((qu: Q)(lb[A]: L) S)) 
        = ((L = cs) implies ((A = hd(Q)) and 
                             (#aq(tl(Q),A) = 0)and 
                             (#ls(S,cs) = 0))) .
}

-- ===============================================================
-- an inductive invariant predicate
mod! INV {pr(STATEpred2)
op inv : -> PnameSeq .
eq inv = wfs mx qep rs ws cs .
pred inv : State .
eq inv(S:State) = cj(inv,S) .
}

-- ===============================================================
-- property specification of QLOCK
mod! QLOCKprop{pr(INIT + INV)}

** ===============================================================
** ================ Proof Score ==================================
** ===============================================================

-- load the module GENcases from genCases.cafe file
-- in genCases.cafe

-- ===============================================================
-- facts to be used
mod! FACTtbu {
pr(QLOCKprop)

-- necessary fact about #aq
eq #aq(Q:Qu & A1:Aid,A2:Aid) = if (A1 = A2) then (s 0) + #aq(Q,A2) 
                               else #aq(Q,A2) fi .

-- for lockout freeness verification 131028
-- about #daq
ceq #daq((Q:Qu & A1:Aid),A2:Aid) = #daq(Q,A2) if not(A1 = A2) .

-- about Peano NAT
eq ((s N:Nat) = N) = false .

}

-- m-and test for 
--> ((qu: (b1 & Q:Qu))(lb[b2]: ws)(lb[b1]: L:Label) S:State)
open (QLOCKsys + QLOCKprop) .
-- literals
[AidConLt < Aid]
eq (B1:AidConLt = B2:AidConLt) = (B1 == B2) .
ops b1 b2 : -> AidConLt .
-- constants declarations
op l : -> Label .
op q : -> Qu . 
op s : -> State .

-- (1)
red cj(ws,((qu: (b1 & q))(lb[b2]: ws)(lb[b1]: rs) s)) and
    cj(ws,((qu: (b1 & q))(lb[b1]: rs)(lb[b2]: ws) s)) .
--> (#aq(q,b2) = (s 0)):Bool

red cj(ws,((qu: (b1 & q))(lb[b2]: ws)(lb[b1]: rs) s)) .
--> '(true):Bool' in the current version,
--> but should return '(#aq(q,b2) = (s 0)):Bool' 
--> if :m-and is supported

--> (2)
red inv((qu: (b1 & q))(lb[b2]: ws)(lb[b1]: rs) s) and
    inv((qu: (b1 & q))(lb[b1]: rs)(lb[b2]: ws) s) .
--> false

red inv((qu: (b1 & q))(lb[b1]: rs)(lb[b2]: ws) s) .
--> not 'false' in the current version,
--> but should be 'false' if :m-and is supported

close

eof