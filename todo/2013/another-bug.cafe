-- cloudsync.cafe
-- educational module to explain CafeOBJ and verification
--
-- TODO:
-- * replace Nat with a parametrized module that requires only a < function
--   on the value parameter, then instantiate it with Nat.
-- * add the missing rewrite equation explicitely and continue fixing
--   stuff
-- 
-- Explanation
-- one cloud computer and arbitrary many PCs have one value each that
-- they want to keep in sync. This value is a natural number and higher
-- means newer (think of svn revision number or similar).
-- The protocoll is simply that the Cloud can be in two states: idlecl, busy
-- and the PCs in the following states:
--   idlepc, gotvalue, updated, finished, sleep
-- A PC can only connect to the cloud (i.e., initiate a sync) if the
-- cloud is in idle state and the PC also in idle state.
-- In this case the Cloud goes into busy state, and the PC into gotvalue
-- where it obtained the value of the cloud (written in gotvalue(n)).
-- After that the PC compares the values, updates them according to the
-- highest value, and goes in updated state.
-- From the updated state PC goes into finished state, and from there
-- PC goes to sleep state, and Cloud goes to idle state.
--
-- Transitions in detail (CloudVal, CloudState, PCVal, PCState)
-- (assuming m<n)
--   (idle,n,idle,m) -> (busy,n,gotvalue(n),m) -> (busy,n,updated,n) ->
--     -> (busy,n,finished,n) -> (idle,n,sleep,n)
--
-- Invariant: If PC is in state finished the values of Cloud and PC agree
--
-- Educational point
-- first do *not* use Cloud states, just have a PC state
--   (-,n,idle,m) -> (-,n,gotvalue(n),m) -> (-,n,updated,n) ->
--     -> (-,n,finished,n) -> (-,n,sleep,n)
--
-- Now if there is a second PC client initiating the same sequence
--   m < n < k (CLoudState,CLoudVal,PC1State,PC1Val,PC2State,PC2Val)
-- we can get the following sequence
--  (-,n,idle,m,idle,k) -PC1-> (-,n,gotvalue(n),m,idle,k) -PC1-> (-,n,updated,n,idle,k) 
--    -PC2-> (-,n,updated,n,gotvalue(n),k) -PC2-> (-,k,updated,n,updated,k) ->
--    -PC2-> (-,k,updated,n,finished,k) (*crit-ok*) -PC2-> (-,k,updated,n,sleep,k) ->
--    -PC1-> (-,k,finished,n,sleep,k) (*crit-error*)
-- since PC1 get the value n which is bigger than his own, so PC1 updates
-- to n. But in the meantime PC2 has update Cloud to k which is bigger
-- than both n and m. At the end we have PC1 in finished state but
-- the respective values do not agree.
--
-- PLAN
-- First present the incorrect modelling, show, that we cannot prove
-- get from the error the above sequence, refine the model to have
-- a state for cloud, show that it is now correct.
--
-- Now for the work ...

mod! CLLABEL {
  [ClLabelLt < ClLabel]
  ops idlecl busy : -> ClLabelLt {constr} .
  -- gen term [idlecl,busy]
  eq (L1:ClLabelLt = L2:ClLabelLt) = (L1 == L2) .
}

mod! PCLABEL {
  [PcLabelLt < PcLabel]
  ops idlepc gotvalue updated finished sleep : -> PcLabelLt {constr} .
  -- gen term [idlepc,gotvalue,updated,finished,sleep]
  eq (L1:PcLabelLt = L2:PcLabelLt) = (L1 == L2) .
}

-- mod* PCID {[Pcid]} we will use Nat here!

mod! PAIR(X :: TRIV,Y :: TRIV) {
  [Pair]
  op <_,_> : Elt.X Elt.Y -> Pair {constr}
  op fst : Pair -> Elt.X
  op snd : Pair -> Elt.Y
  eq fst(< A:Elt.X,B:Elt.Y >) = A .
  eq snd(< A:Elt.X,B:Elt.Y >) = B .
}

-- generic set 
mod! SET(X :: TRIV) {
  [Elt.X < Set]
  -- empty set
  op empty : -> Set {constr} .
  -- assicative and commutative set constructor with identity empty
  op (_ _) : Set Set -> Set {constr assoc comm id: empty} .
  -- (_ _) is idempotent
  eq E:Elt E = E .
}

mod! CLSTATE { 
  pr(PAIR(NAT, CLLABEL{sort Elt -> ClLabel})*{sort Pair -> ClState, op fst -> fst.clstate, op snd -> snd.clstate }) 
  -- gen term: GenPairs([Nat], [idlecl,busy])
}

-- PCVALs collects the current value at the PC and the value at the cloud
-- the value of the cloud is only used after a getvalue transition
-- strange error :
-- CafeOBJ> mod! PCSTATE { pr(PAIR(NAT, PCSTATEVAL{sort Elt -> PcStateVal})*{sort Pair -> PcState, op fst -> fst.pcstate, op snd -> snd.pcstate }) }
--
-- -- defining module! PCSTATE
-- [Warning]: redefining module PCSTATE ,,,,,,,,,,,,,,,,,,,*,,,,,,,*,,,,,
-- !! PANIC !!: setup error operator: error sort of PcVals is not yet prepared!.
--  object=[:sort "PcVals"]
--  so=#<eq hash-table with 12 entries @ #x21cfa6e2>
-- [Sort : SyntaxErr]([:sort "SyntaxErr"])
--  Subsorts :  TypeErr( [:sort "TypeErr"])
--  Supersorts : ()
--  Errorsort : ?SyntaxErr([:sort "?SyntaxErr"])
-- mod! PCVALS { pr(PAIR(NAT{sort Elt -> Nat},NAT{sort Elt -> Nat})*{sort Pair -> PcVals, op fst -> fst.pcvals, op snd -> snd.pcvals }) }

mod! PCSTATE { 
  pr(3TUPLE(NAT, NAT, PCLABEL{sort Elt -> PcLabel})*{sort 3Tuple -> PcState})
  -- gen term: GenTriples( [Nat], [Nat], 
  --                       [idlepc,gotvalue,updated,finished,sleep])
}

mod! PCSTATES { 
  pr(SET(PCSTATE{sort Elt -> PcState})*{sort Set -> PcStates}) 
  -- gen term: GenSets( GenTriples( [Nat], [Nat], 
  --                                [idlepc,gotvalue,updated,finished,sleep]))
}

mod! STATE { 
  pr(PAIR(CLSTATE{sort Elt -> ClState},PCSTATES{sort Elt -> PcStates})*{sort Pair -> State}) 
  -- gen term:
  -- GenPairs( GenPairs([Nat], [idlecl,busy]),
  --           GenSets( GenTriples( [Nat], [Nat], 
  --                                [idlepc,gotvalue,updated,finished,sleep])))
}

--
-- declaration of the transitions between states
--

mod! GETVALUE { pr(STATE)
  -- since set is comm,assoc,dist we can assume that the first element
  -- of the set is th one that acts
  trans[getvalue]: 
    < < ClVal:Nat , idlecl > , ( << PcVal:Nat ; OldClVal:Nat ; idlepc >> S:PcStates ) >
    =>
    < < ClVal , busy > , ( << PcVal ; ClVal ; gotvalue >> S ) > .
}

mod! UPDATE {
  pr(STATE)
  trans[update]:
    < < ClVal:Nat , busy > , ( << PcVal:Nat ; GotClVal:Nat ; gotvalue >> S:PcStates ) >
    =>
      if PcVal <= GotClVal then
	< < ClVal , busy > , ( << GotClVal ; GotClVal ; updated >> S ) >
      else
	< < PcVal , busy > , ( << PcVal ; GotClVal ; updated >> S ) >
      fi .
}
 
mod! FINISH {
  pr(STATE)
  trans[finish]: 
    < < ClVal:Nat , busy > , ( << PcVal:Nat ; OldClVal:Nat ; updated >> S:PcStates ) >
    =>
    < < ClVal , busy > , ( << PcVal ; OldClVal ; finished >> S ) > .
}

mod! GOTOSLEEP {
  pr(STATE)
  trans[gotosleep]: 
    < < ClVal:Nat , busy > , ( << PcVal:Nat ; OldClVal:Nat ; finished >> S:PcStates ) >
    =>
    < < ClVal , idlecl > , ( << PcVal ; OldClVal ; sleep >> S ) > .
}

mod! CLOUD { pr(GETVALUE + UPDATE + FINISH + GOTOSLEEP) }

-- ------------------------------------------------------------
-- proof score
-- ------------------------------------------------------------
-- how to prove correctness of this method
--
-- valid states
--   given by the format, no need for further specification
-- qualify an initial state:
--   cloud and all PCs are in idle state
-- induction properties
--   all PCs in updated and finished state agree between their and the cloud value
--   all PCs in gotvalue state have their gotvalue equal to cloud value

-- Peano Style Natural Numbers with ac-_+_ 
mod! PNAT+ac {
  [Nat]
  op 0 : -> Nat {constr} .
  op s_ : Nat -> Nat {constr} .
  -- equality over the natural numbers
  eq (0 = s(Y:Nat)) = false .
  eq (s(X:Nat) = s(Y:Nat)) = (X = Y) .
  -- associative and commutative _+_
  op _+_ : Nat Nat -> Nat {assoc comm}
  eq 0 + Y:Nat = Y .
  eq (s X:Nat) + Y:Nat = s(X + Y) .
}

-- elementary functions on states 
mod! STATEfuncs {
  pr(PNAT+ac + STATE) 
  -- no pc in gotvalue state
  pred zero-gotvalue : State .
  pred zero-gotvalue-pcs : PcStates .
  eq zero-gotvalue ( < C:ClState , PCS:PcStates > ) = zero-gotvalue-pcs(PCS) .
  eq zero-gotvalue-pcs ( << N:Nat.NAT ; M:Nat.NAT ; L:PcLabel >> PS:PcStates ) = 
    if L = gotvalue then false  else zero-gotvalue-pcs (PS) fi .
  -- no pc in updated state
  pred zero-updated : State .
  pred zero-updated-pcs : PcStates .
  eq zero-updated ( < C:ClState , PCS:PcStates > ) = zero-updated-pcs(PCS) .
  eq zero-updated-pcs ( << N:Nat.NAT ; M:Nat.NAT ; L:PcLabel >> PS:PcStates  ) = 
    if L = updated then false  else zero-updated-pcs (PS) fi .
  -- no pc in finished state
  pred zero-finished : State .
  pred zero-finished-pcs : PcStates .
  eq zero-finished ( < C:ClState , PCS:PcStates > ) = zero-finished-pcs(PCS) .
  eq zero-finished-pcs ( << N:Nat.NAT ; M:Nat.NAT ; L:PcLabel >> PS:PcStates ) = 
    if L = finished then false  else zero-finished-pcs (PS) fi .
  -- no pc in sleep state
  pred zero-sleep : State .
  pred zero-sleep-pcs : PcStates .
  eq zero-sleep ( < C:ClState , PCS:PcStates > ) = zero-sleep-pcs(PCS) .
  eq zero-sleep-pcs ( << N:Nat.NAT ; M:Nat.NAT ; L:PcLabel >> PS:PcStates ) = 
    if L = sleep then false  else zero-sleep-pcs (PS) fi .
}


mod! APPLYPREDS {
  pr(STATE)
  [PredName < PredNameSeq]
  op (_ _) : PredNameSeq PredNameSeq -> PredNameSeq {assoc} .
  op apply : PredNameSeq State -> Bool .
  eq apply(P:PredName PS:PredNameSeq, S:State) = apply(P,S) and apply(PS,S) .
}

mod! INITPREDS {
  pr(STATEfuncs)
  ex(APPLYPREDS)
  -- we don't need well defined predicate, as this is implicite by
  -- the format of the pairs, and we have no restriction on the
  -- content ... or maybe we need that
  -- if cloud is in idle state all the other have to be either in idle
  -- or done state ???
  -- verification of coverage 
  -- generator term for State is
  -- GenPairs( GenPairs([NAT],[idlecl,busy]) , 
  --           GenSet(GenTriples([Nat], 
  --                             [Nat], 
  --                             [idlepc,gotvalue,updated,finished,sleep])))
  -- the condition that we can generate a full cover is that all predicates
  -- that we use to define any property do not
  --
  -- Cloud is in idle state
  op cl-is-idle-name : -> PredName .
  eq[cl-is-idle] : apply(cl-is-idle-name,S:State) = ( snd(fst(S)) = idlecl ) .
  --
  -- all the PCs are in idle state
  op pcs-are-idle-name : -> PredName .
  eq[pcs-are-idle] : apply(pcs-are-idle-name,S:State) = 
    zero-gotvalue(S) and zero-updated(S) and zero-finished(S) and zero-sleep(S) .
}

mod! INITIALSTATE {
  pr(INITPREDS)
  op init-name : -> PredNameSeq .
  eq init-name = cl-is-idle-name pcs-are-idle-name .
  pred init : State .
  eq init(S:State) = apply(init-name, S) .
}

-- ----------------------------
-- invariant properties through transitions
--
--  all PCs in updated and finished state agree between their and 
--         the cloud value
--  all PCs in gotvalue state have their gotvalue equal to cloud value
--  if Cloud is in idle state, then all the PCs are either in idle
--         or finished state 
-- --------------------

-- TODO TODO TODO TODO TODO TODO TODO
-- we need to show for inv(s) -> inv(ss) that 
-- only *one* PC can be out of the idle/sleep states

mod! INVPREDS {
  pr(INITPREDS)
  vars K N M : Nat.NAT
  -- if Cloud is in idle state, all the PCs have to be in idle or sleep
  op cloud-idle-pcs-idle-sleep-name : -> PredName .
  pred cloud-idle-pcs-idle-sleep : State .
  pred pcstates-idle-sleep : PcStates .
  eq[cloud-idle-pcs-idle-sleep] : 
    apply(cloud-idle-pcs-idle-sleep-name, S:State) = cloud-idle-pcs-idle-sleep(S) .
  eq cloud-idle-pcs-idle-sleep(if B:Bool then S1:State else S2:State fi) =
    if B then cloud-idle-pcs-idle-sleep(S1) else cloud-idle-pcs-idle-sleep(S2) fi .
  eq cloud-idle-pcs-idle-sleep( < < N , idlecl > , PCS:PcStates > ) = 
    zero-gotvalue-pcs(PCS) and zero-updated-pcs(PCS) and zero-finished-pcs(PCS) .
  ceq cloud-idle-pcs-idle-sleep( < < N , L:ClLabel > , PCS:PcStates > ) =
    true if not (L = idlecl) .
  -- 
  --  all PCs in gotvalue state have their gotvalue equal to cloud value
  op gotvalue-cloud-value-name : -> PredName .
  pred gotvalue-cloud-value : State .
  pred pcstates-gotvalue-cloud-value : Nat.NAT PcStates .
  eq[gotvalue-cloud-value] : 
    apply(gotvalue-cloud-value-name, S:State) = gotvalue-cloud-value(S) .
  -- do we care for the fact that CS:ClLabel can only be busy??
  eq gotvalue-cloud-value(if B:Bool then S1:State else S2:State fi) =
    if B then gotvalue-cloud-value(S1) else gotvalue-cloud-value(S2) fi .
  eq gotvalue-cloud-value( < < N , CS:ClLabel > , PCS:PcStates > ) =
    if zero-gotvalue-pcs(PCS) then
      true
    else
      pcstates-gotvalue-cloud-value(N, PCS)
    fi .
  eq pcstates-gotvalue-cloud-value(N, empty) = true .
  eq pcstates-gotvalue-cloud-value(N, << K ; N ; gotvalue >> PP:PcStates) = 
    pcstates-gotvalue-cloud-value(N, PP) .
  ceq pcstates-gotvalue-cloud-value(N, << K ; M ; S:PcLabel >> PP:PcStates) =
    pcstates-gotvalue-cloud-value(N, PP) if not (S = gotvalue) .

  --  all PCs in updated and finished state agree between their and 
  --  the cloud value
  op goal-name : -> PredName .
  pred goal : State .
  pred pcstates-goal : Nat.NAT PcStates .
  eq[goal] : apply(goal-name, S:State) = goal(S) .
  eq goal(if B:Bool then S1:State else S2:State fi) = 
    if B then goal(S1) else goal(S2) fi .
  eq goal( < < N, CS:ClLabel > , PCS:PcStates > ) = 
    if zero-finished-pcs(PCS) then
      true
    else
      pcstates-goal(N, PCS)
    fi .
  eq pcstates-goal(N, empty) = true .
  eq pcstates-goal(N, << N ; M ; updated >> PP:PcStates ) =
    pcstates-goal(N, PP) .
  eq pcstates-goal(N, << N ; M ; finished >> PP:PcStates ) =
    pcstates-goal(N, PP) .
  ceq pcstates-goal(N, << K ; M ; CL:PcLabel >> PP:PcStates ) =
    pcstates-goal(N, PP) if not ((CL = updated) or (CL = finished)) .

  -- only at most one PC is out of the sleep and idle state
  op one-active-name : -> PredName .
  pred one-active : State .
  eq[one-active] : apply(one-active-name, S:State) = one-active(S) .
  eq one-active(if B:Bool then S1:State else S2:State fi) = 
    if B then one-active(S1) else one-active(S2) fi .
  eq one-active ( < C:ClState , ( << K ; M ; gotvalue >> PCS:PcStates ) > )
    = ( zero-updated(< C , PCS >) and zero-finished(< C , PCS >)
	and zero-gotvalue(< C , PCS >) ) .
  eq one-active ( < C:ClState , ( << K ; M ; updated >> PCS:PcStates ) > )
    = ( zero-updated(< C , PCS >) and zero-finished(< C , PCS >)
	and zero-gotvalue(< C , PCS >) ) .
  eq one-active ( < C:ClState , ( << K ; M ; finished >> PCS:PcStates ) > )
    = ( zero-updated(< C , PCS >) and zero-finished(< C , PCS >)
	and zero-gotvalue(< C , PCS >) ) .
  eq one-active ( < C:ClState , ( << K ; M ; idlepc >> PCS:PcStates ) > )
    = one-active ( < C , PCS > ) .
  eq one-active ( < C:ClState , ( << K ; M ; sleep >> PCS:PcStates ) > )
    = one-active ( < C , PCS > ) . 
}


mod! INVARIANT {
  pr(INVPREDS)
  op invariant-name : -> PredNameSeq .
  eq invariant-name = cloud-idle-pcs-idle-sleep-name gotvalue-cloud-value-name goal-name one-active-name .
  pred invariant : State .
  eq invariant(S:State) = apply(invariant-name, S) .
}

mod! CLOUDSYNCPROP {
  pr(INITIALSTATE + INVARIANT)
}

mod! NECESSARYFACTS {
  pr(CLOUDSYNCPROP)
  vars M N : Nat.PNAT+ac
  vars U V W : Nat.NAT
  -- necessary fact about _=_ on Nat
  eq ((M + N) = 0) = ((M = 0) and (N = 0)) . 
  -- a strange thing that this property is necessary
  eq (if B:Bool then true else D:Bool fi) and B = B .
  --
  eq ( zero-gotvalue-pcs(PCS:PcStates) and zero-updated-pcs(PCS) and 
       zero-finished-pcs(PCS) and one-active( < C:ClState, PCS > )) = 
	 zero-gotvalue-pcs(PCS) and zero-updated-pcs(PCS) and 
	   zero-finished-pcs(PCS) .

  eq ( zero-gotvalue-pcs(PCS:PcStates) and 
       pcstates-gotvalue-cloud-value( L:Nat.NAT , PCS ) ) = 
	 zero-gotvalue-pcs(PCS) .
}


-- ---------------------------------------------
-- covering terms
-- GenPairs( GenPairs([NAT],[idlecl,busy]) , 
--           GenSet(GenTriples([Nat], 
--                             [Nat], 
--                             [idlepc,gotvalue,updated,finished,sleep])))
-- < < N:Nat , idlecl > , ( << M:Nat ; K:Nat ; idlepc   >> PCS:PcStates ) >
-- < < N:Nat , idlecl > , ( << M:Nat ; K:Nat ; gotvalue >> PCS:PcStates ) >
-- < < N:Nat , idlecl > , ( << M:Nat ; K:Nat ; updated  >> PCS:PcStates ) >
-- < < N:Nat , idlecl > , ( << M:Nat ; K:Nat ; finished >> PCS:PcStates ) >
-- < < N:Nat , idlecl > , ( << M:Nat ; K:Nat ; sleep    >> PCS:PcStates ) >
-- < < N:Nat , busy   > , ( << M:Nat ; K:Nat ; idlepc   >> PCS:PcStates ) >
-- < < N:Nat , busy   > , ( << M:Nat ; K:Nat ; gotvalue >> PCS:PcStates ) >
-- < < N:Nat , busy   > , ( << M:Nat ; K:Nat ; updated  >> PCS:PcStates ) >
-- < < N:Nat , busy   > , ( << M:Nat ; K:Nat ; finished >> PCS:PcStates ) >
-- < < N:Nat , busy   > , ( << M:Nat ; K:Nat ; sleep    >> PCS:PcStates ) >  


open (CLOUD + CLOUDSYNCPROP) .
  pr(NECESSARYFACTS)
  vars M N K : Nat.NAT
  var PCS : PcStates .
  ops s1 s2 s3 s4 s5 : -> State .
  ops t1 t2 t3 t4 t5 : -> State .
  eq s1 =  < < N , idlecl > , ( << M ; K ; idlepc   >> PCS ) >  .
  eq s2 =  < < N , idlecl > , ( << M ; K ; gotvalue >> PCS ) >  .
  eq s3 =  < < N , idlecl > , ( << M ; K ; updated  >> PCS ) >  .
  eq s4 =  < < N , idlecl > , ( << M ; K ; finished >> PCS ) >  .
  eq s5 =  < < N , idlecl > , ( << M ; K ; sleep    >> PCS ) >  .
  eq t1 =  < < N , busy   > , ( << M ; K ; idlepc   >> PCS ) >  .
  eq t2 =  < < N , busy   > , ( << M ; K ; gotvalue >> PCS ) >  .
  eq t3 =  < < N , busy   > , ( << M ; K ; updated  >> PCS ) >  .
  eq t4 =  < < N , busy   > , ( << M ; K ; finished >> PCS ) >  .
  eq t5 =  < < N , busy   > , ( << M ; K ; sleep    >> PCS ) >  .
  -- show that if s is an initial state, then it has the invariant property
  -- this is the base case of the induction
  -- red init(s1) implies invariant(s1) . -- OK
  -- red init(s2) implies invariant(s2) . -- OK
  -- red init(s3) implies invariant(s3) . -- OK
  -- red init(s4) implies invariant(s4) . -- OK
  -- red init(s5) implies invariant(s5) . -- OK
  -- red init(t1) implies invariant(t1) . -- OK
  -- red init(t2) implies invariant(t2) . -- OK
  -- red init(t3) implies invariant(t3) . -- OK
  -- red init(t4) implies invariant(t4) . -- OK
  -- red init(t5) implies invariant(t5) . -- OK
  -- YEAH, init(S) implies invariant(S) has been shown for all
  -- elements of a cover set of the states

-- now we have to show the invariant case, such that if we are in a state
-- that has the invariant property, then all the following states also
-- have the invariant property
  vars S SS : State .
  op inv-condition : State State -> Bool .
  eq inv-condition(S, SS) =
    (not (S =(*,1)=>+ SS
       suchThat (not((invariant(S) implies invariant(SS)) == true)))) .

  -- red inv-condition(s1, SS) . -- OK
  -- red inv-condition(s2, SS) . -- OK
  -- red inv-condition(s3, SS) . -- OK
  -- red inv-condition(s4, SS) . -- OK 
  -- red inv-condition(s5, SS) . -- OK
  -- red inv-condition(t1, SS) . -- OK
  red inv-condition(t2, SS) . -- probably OK (reduction not done completely!)
  -- red inv-condition(t3, SS) . -- FALSE
  -- red inv-condition(t4, SS) . -- OK
  -- red inv-condition(t5, SS) . -- OK

  -- set trace whole on

  -- ---------------------------
  -- red inv-condition(t2, SS) .
  -- t2 =  < < N , busy   > , ( << M ; K ; gotvalue >> PCS ) > 
  -- u  =  < (< N , busy >) , ((<< M ; N ; gotvalue >>) PCS ) >
  -- u  = (if (M <= K) then (< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >) else (< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >) fi)
  -- eq M <= K = false .
  red invariant ( < < N , busy   > , ( << M ; K ; gotvalue >> PCS ) > )
      implies
      invariant ( if (M <= K) then (< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >) else (< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >) fi ) .

  -- this produces a long formula that *should* reduce to simpler cases:
-- (
--  (
--    pcstates-gotvalue-cloud-value(N,((<< M ; K ; gotvalue >>) PCS))
--    and
--    zero-updated-pcs(PCS)
--    and
--    zero-gotvalue-pcs(PCS)
--    and
--    zero-finished-pcs(PCS)
--    and
--        if (M <= K) then
--          cloud-idle-pcs-idle-sleep((< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >))
--        else
--          cloud-idle-pcs-idle-sleep((< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >))
--        fi
--    and    
--        if (M <= K) then
--          gotvalue-cloud-value((< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >))
--        else
--          gotvalue-cloud-value((< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >))
--        fi
--    and  
--        if (M <= K) then
--          goal((< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >))
--        else
--          goal((< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >))
--        fi
--    and  
--        if (M <= K) then
--          one-active((< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >))
--        else
--          one-active((< (< M , busy >) , ((<< M ; K ; updated >>) PCS) >))
--        fi
--  )
--  xor
--  (
--    (
--      pcstates-gotvalue-cloud-value(N,((<< M ; K ; gotvalue >>) PCS))
--      and
--      zero-updated-pcs(PCS)
--      and
--      zero-gotvalue-pcs(PCS)
--      and
--      zero-finished-pcs(PCS)))
--    )
--    xor
--    true
--  )
-- )

-- The interesting case is that the inner parts of the if 
-- are *NOT* reduced anymore!!

-- example
-- 
--   red cloud-idle-pcs-idle-sleep((< (< N , busy >) , ((<< K ; K ; updated >>) PCS) >)) .
-- gives *true* but that is not reduced anymore!!!

-- I checked all the cases and with full reduction the case of
-- invariant(t2) would also be solved!!!!


eof

