-- ========= input file ==========
-- generate cases by expanding alternatives
mod TEST {pr(NAT + STRING)

-- ValSq: sequences of Val
[Val < ValSq]
op empVs : -> ValSq {constr}
op _,_ : ValSq ValSq -> ValSq {constr assoc id: empVs}

-- redundancy check of ValSq w.r.t. literals
-- literal constructor
op _lt_ : String Nat -> Val .
ops v1 v2 : -> Val .

-- pair of sort name string and its count (Psc)
-- and set of Psc
[Psc < PscSet]
op sn : String Nat -> Psc {constr}
op empPsc : -> PscSet {constr}
op __ : PscSet PscSet -> PscSet {constr assoc comm id: empPsc}

-- checking redundant seq of literals
pred rddt : ValSq PscSet .

eq[0]: rddt(empVs,PS:PscSet) = true .

ceq[1]: rddt((V:Val,VS:ValSq),PS:PscSet) =
    (if (N1:Nat <= N2:Nat) then rddt(VS,PS)
     else if (N1 == N2 + 1) then rddt(VS,(sn(S:String,N1) PS))
     else false fi fi)
  if ((S)lt(N1) := V) and-also ((sn(S,N2) PS1:PscSet) := PS) .

ceq[2]: rddt((V:Val,VS:ValSq),PS:PscSet) =
    (if (N1:Nat == 1) then rddt(VS,(sn(S:String,1) PS)) else false fi)
  if ((S)lt(N1) := V) and-also not((sn(S,N2:Nat) PS1:PscSet) := PS) .

ceq[3]: rddt((V:Val,VS:ValSq),PS:PscSet) = rddt(VS,PS)
  if not((S:String)lt(N1:Nat) := V) .

}

set trace whole on
open TEST .
red rddt(("s" lt 1),empPsc) .
--> true as expected
red rddt((("s" lt 1),("s" lt 2)),empPsc) .
--> true, but ...
red rddt((("s" lt 1),("t" lt 2)),empPsc) .
--> true but should be false
close

eof
