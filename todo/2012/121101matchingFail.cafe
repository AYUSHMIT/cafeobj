-- bits (2 elemnts) for alternation
mod! BIT {
 [BitLt < Bit]
 ops b0 b1 : -> BitLt .
 eq (B1:BitLt = B2:BitLt) = (B1 == B2) .
 op not : Bit -> Bit .
 eq not(b0) = b1 .
 eq not(b1) = b0 .
 eq (B:Bit = not(B)) = false .
}

-- natural numbers in Peano style
mod! NNUM {
 [NzNat NatLt < Nat]
 op 0 : -> Nat .
 op s_ : Nat -> NzNat .
 op p_ : NzNat -> Nat .
 eq (p (s N:Nat)) = N .
 eq (0 = 0) = true .
 eq (0 = s N:Nat) = false .
 eq (s N1:Nat = s N2:Nat) = (N1 = N2) .
 --
 eq (N1:NatLt = N2:NatLt) = (N1 == N2) .
 -- facts
 eq (N:Nat = (s N)) = false .
}

-- pair of bit and natural number
mod! BN-PAIR {
 pr(BIT + NNUM)
 [BNpair]
 op bn : Bit Nat -> BNpair .
 eq (bn(B1:Bit,N1:Nat) = bn(B2:Bit,N2:Nat))
    = (B1 = B2) and (N1 = N2) .
 op 1st : BNpair -> Bit .
 eq 1st(bn(B:Bit,N:Nat)) = B .
 op 2nd : BNpair -> Nat .
 eq 2nd(bn(B:Bit,N:Nat)) = N .
}

mod* TRIV= {
  [Elt]
  pred _=_ : Elt Elt {comm}.
  eq (E:Elt = E) = true .
}

-- Sequence without {id: emp}
mod* SEQ (X :: TRIV=) {
  [Elt < Seq]
  -- empty Sequence
  op emp : -> Seq . 
  op (_ _) : Seq Seq -> Seq {constr assoc}
  eq (emp S:Seq) = S .
  eq (S:Seq emp) = S .
  --
  eq (emp = E:Elt) = false .
  eq (emp = (E:Elt S:Seq)) = false .
  eq (emp = (S:Seq E:Elt)) = false .
  eq (E1:Elt = (E21:Elt E22:Elt)) = false .
  eq (E1:Elt = (E21:Elt E22:Elt S2:Seq)) = false .
  eq (E1:Elt = (S1:Seq E21:Elt E22:Elt)) = false .
  eq ((E11:Elt E12:Elt) = (E21:Elt E22:Elt))
  = ((E11 = E21) and (E12 = E22)) .
  eq ((E11:Elt E12:Elt) = (E21:Elt E22:Elt S2:Seq))
  = ((E11 = E21) and (E12 = E22) and (emp = S2)) .
  eq ((E11:Elt E12:Elt S1:Seq) = (E21:Elt E22:Elt S2:Seq))
  = ((E11 = E21) and (E12 = E22) and (S1 = S2)) .
  --
  -- left hd and right tail
  op lhd : Seq -> Elt .
  eq lhd(E:Elt) = E .
  eq lhd(E:Elt S:Seq) = E .
  --
  op rtl : Seq -> Seq .
  eq rtl(E:Elt) = emp .
  eq rtl(E:Elt S:Seq) = S .
  --
  op rhd : Seq -> Elt .
  eq rhd(E:Elt) = E .
  eq rhd(S:Seq E:Elt) = E .
  --
  op ltl : Seq -> Seq .
  eq ltl(E:Elt) = emp .
  eq ltl(S:Seq E:Elt) = S .

  -- facts, or assertions about operations on emp
  eq (lhd(emp) = E:Elt) = false .
  eq (rhd(emp) = E:Elt) = false .
  ceq (S:Seq = emp) = false if (lhd(S) = E:Elt) .
  ceq (S:Seq = emp) = false if (rhd(S) = E:Elt) .
  eq ((E:Elt S1:Seq) = (E S2:Seq)) = (S1 = S2) .

  -- facts: assertions about ops on emp
  eq (lhd(emp) = E:Elt) = false .
  eq (rhd(emp) = E:Elt) = false .
  eq ((S:Seq = emp) and (lhd(S) = E:Elt)) = false .
  eq ((S:Seq = emp) and (rhd(S) = E:Elt)) = false .

  eq ((S1:Seq = S2:Seq) and (S1 = (E:Elt S3:Seq S2))) = false .
  eq ((S1:Seq = (E1:Elt S2:Seq)) and ((E2:Elt S1) = S2)) = false .

}

mod! NUM-SEQ {
 pr(SEQ(NNUM{ sort Elt -> Nat,
	      op (E1:Elt = E2:Elt) -> (E1:Nat = E2:Nat)})
    *{ sort Seq -> Nseq, op emp -> empN })

 op mk : Nat -> Nseq .
 eq mk(0) = (0 empN) .
 eq mk(N:NzNat) = (N mk(p(N))) .

 -- fact 121002
 ceq (mk(N1:Nat) = (N2:Nat NS:Nseq)) = false if not(N1 = N2) .
}

-- receiver to sender channel
mod! RSCH {
  pr(SEQ(BIT{sort Elt -> Bit
             op (E1:Elt = E2:Elt) -> (E1:Bit = E2:Bit)})
     *{sort Seq -> RSch, op emp -> empB})}

-- Sender-receiver channel: sequence of Bit-Nat pairs
mod! SRCH {
  pr(SEQ(BN-PAIR{sort Elt -> BNpair
                 op (E1:Elt = E2:Elt) -> (E1:BNpair = E2:BNpair)})
     *{sort Seq -> SRch,op emp -> empBN})
}

-- a state is defined as a set of observers
mod* STATE {
  pr(SRCH)
  pr(NUM-SEQ)
  pr(RSCH)
  -- state is a set of observers
  [Obs < State]
  -- state constructor
  op _ _ : State State -> State {constr assoc comm idem}
  -- 6 kinds of observers
  op (sBit:_) : Bit -> Obs {constr}   -- Sender's bit
  op (sNum:_) : Nat -> Obs {constr}   -- the number Sender wants to deliver 
  op (srCh:_) : SRch -> Obs {constr}  -- Sender-to-Receiver channel
  op (rBit:_) : Bit -> Obs {constr}   -- Receiver's bit
  op (rNums:_) : Nseq -> Obs {constr} -- the sequence of numbers received by Receiver
  op (rsCh:_) : RSch -> Obs {constr}  -- Receiver-to-Sender channel
}

-- events that cause state transitions
mod! EVENT {
 [EventLt < Event]
 ops ss drSr duSr rr rs drRs duRs sr : -> EventLt .
 eq (E1:EventLt = E2:EventLt) = (E1 == E2) .
}

-- ABP (alternating bit protocol) 
mod* ABP {
  pr(STATE)
  pr(EVENT)
  op trans : State Event -> State .
  -- 
  var S : State .
  vars B Bs Br : Bit .
  var N : Nat .
  vars SRC SRC1 SRC2 : SRch .
  var BNP : BNpair .
  var NS : Nseq .
  vars RSC RSC1 RSC2 : RSch .

  -- (sBit: Bs)(sNum: N)(srCh: SRC)(rBit: Br)(rNums: Nseq)(rsCh: RSC)
  -- ( and ) enclosing if_the_else_fi is needed in a ceq
  -- datum is getting through all the Sequences from left to right

  -- Sender's sending a bit-number pair through srCh
  -- srCh : sender to receiver channel
  eq[ss]: trans(((sBit: Bs)(sNum: N)(srCh: SRC) S), ss)
          = ((sBit: Bs)(sNum: N)(srCh: (bn(Bs,N) SRC)) S) .
  -- for selecting dropping or duplication point non-deterministically
  -- is it needed?121020
  -- ops x-sr y-sr : SRch -> SRch .
  -- data drop from srCh
  eq[drSr1]: trans((srCh: empBN) S, drSr) = ((srCh: empBN) S) .
  eq[drSr2]: trans((srCh: BNP) S, drSr) = ((srCh: empBN) S) .
  eq[drSr3]: trans((srCh: (BNP SRC2)) S, drSr) = ((srCh: (SRC2)) S) .
  eq[drSr4]: trans((srCh: (SRC1 BNP)) S, drSr) = ((srCh: (SRC1)) S) .
  eq[drSr5]: trans((srCh: (SRC1 BNP SRC2)) S, drSr) = ((srCh: (SRC1 SRC2)) S) .
  -- data duplication in srCh
  eq[duSr1]: trans((srCh: empBN) S, duSr) = ((srCh: empBN)S) .
  eq[duSr2]: trans((srCh: BNP) S, duSr) = ((srCh: (BNP BNP)) S) .
  eq[duSr3]: trans((srCh: (SRC1 BNP)) S, duSr) = ((srCh: (SRC1 BNP BNP)) S) .
  eq[duSr4]: trans((srCh: (BNP SRC2)) S, duSr) = ((srCh: (BNP BNP SRC2)) S) .
  eq[duSr5]: trans((srCh: (SRC1 BNP SRC2)) S, duSr) = ((srCh: (SRC1 BNP BNP SRC2)) S) .
  -- Receiver's receiving a bit number pair from srCh
  eq[rr1]: trans(((srCh: empBN)(rBit: Br)(rNums: NS) S), rr)
           = ((srCh: empBN)(rBit: Br)(rNums: NS) S) .
  eq[rr2]: trans(((srCh: BNP)(rBit: Br)(rNums: NS) S), rr)
           = if (1st(BNP) = Br) 
             then ((srCh: empBN)(rBit: not(Br))(rNums: (2nd(BNP) NS)) S)
             else ((srCh: empBN)(rBit: Br)(rNums: NS) S) fi .
  eq[rr3]: trans(((srCh: (SRC BNP))(rBit: Br)(rNums: NS) S), rr)
           = if (1st(BNP) = Br) 
             then ((srCh: SRC)(rBit: not(Br))(rNums: (2nd(BNP) NS)) S)
             else ((srCh: SRC)(rBit: Br)(rNums: NS) S) fi .
  -- Receiver's sending a bit number to rsCh
  -- rsCh : receiver to sender channel
  eq[rs]: trans(((rBit: Br)(rsCh: RSC) S), rs) = ((rBit: Br)(rsCh: (Br RSC)) S) .
  -- data drop from rsCh
  eq[drRs1]: trans((rsCh: empB) S, drRs) = ((rsCh: empB) S) .
  eq[drRs2]: trans((rsCh: B) S, drRs) = ((rsCh: empB) S) .
  eq[drRs3]: trans((rsCh: (RSC1 B)) S, drRs) = ((rsCh: (RSC1)) S) .
  eq[drRs4]: trans((rsCh: (B RSC2)) S, drRs) = ((rsCh: (RSC2)) S) .
  eq[drRs5]: trans((rsCh: (RSC1 B RSC2)) S, drRs) = ((rsCh: (RSC1 RSC2)) S) .
  -- data duplication in rsCh
  eq[duRs1]: trans((rsCh: empB) S, duRs) = ((rsCh: empB)S) .
  eq[duRs2]: trans((rsCh: B) S, duRs) = ((rsCh: (B B)) S) .
  eq[duRs3]: trans((rsCh: (RSC1 B)) S, duRs) = ((rsCh: (RSC1 B B)) S) .
  eq[duRs4]: trans((rsCh: (B RSC2)) S, duRs) = ((rsCh: (B B RSC2)) S) .
  eq[duRs5]: trans((rsCh: (RSC1 B RSC2)) S, duRs) = ((rsCh: (RSC1 B B RSC2)) S) .
  -- Sender's receiving an ack (a bit)
  eq[sr1]: trans((rsCh: empB)(sBit: Bs)(sNum: N) S, sr)
          = ((rsCh: empB)(sBit: Bs)(sNum: N) S) .
  eq[sr2]: trans(((rsCh: B)(sBit: Bs)(sNum: N) S), sr)
          = if (B = Bs) 
            then ((rsCh: empB)(sBit: Bs)(sNum: N) S)
            else ((rsCh: empB)(sBit: B)(sNum: (s N)) S) fi .
  eq[sr3]: trans((rsCh: (RSC B))(sBit: Bs)(sNum: N) S, sr)
          = if (B = Bs) 
            then ((rsCh: RSC)(sBit: Bs)(sNum: N) S)
            else ((rsCh: RSC)(sBit: B)(sNum: (s N)) S) fi .
}

--
-- start of proof score for ABP
--

-- a theory for transition system with Pre and Post Predicates
mod* TPP {
  pr(ABP)
  op pre : State -> Bool .
  op post : State -> Bool .
}

-- defining the pre-post predicate for a TPP
mod PPP (TS :: TPP) {
  pr(ABP)
  op ppp : State Event -> Bool .
  eq ppp(S:State,E:Event) = pre(S) implies post(trans(S,E)) .
}

-- formal parameter module for ABP (a transition system)
-- with a pre-post predicate
mod* TPPP {
  pr(ABP)
  op ppp : State Event -> Bool .
}

-- for indicating the pre-post predicate 
-- for a specific state 
mod INDppp (TS :: TPPP) {
  pr(ABP)

  [Indicator]
  -- the first argument show whether the ppp holds for
  -- the state that is described by a state configuration
  -- in the second argument
  op i : Bool State Event -> Indicator {constr} .

  -- for defining a list of arguments for 
  -- operator mi_
  [Bit Nat SRch BNpair Nseq RSch Event < Val < ValSq]
  op _,_ : ValSq ValSq -> ValSq {assoc} .

  -- make indicators: it is specific to ABP
  op mi_ : ValSq -> Indicator  .
  -- notice that this following rules can apply 
  -- only after the generation rules defined in the module GEN- below apply
  -- and all the arguments become Val element
  eq mi(Bs:Bit,N:Nat,SRC:SRch,Br:Bit,NS:Nseq,RSC:RSch,E:Event)
  = i(ppp(((sBit: Bs)(sNum: N)(srCh: SRC)
	   (rBit: Br)(rNums: NS)(rsCh: RSC)),E),
      ((sBit: Bs)(sNum: N)(srCh: SRC)
       (rBit: Br)(rNums: NS)(rsCh: RSC)),
      E) .
}

-- a theory with i and mi_
mod* MI {
  [State, Event, Val < ValSq, Indicator]
  op i : Bool State Event -> Indicator {constr} .
  op _,_ : ValSq ValSq -> ValSq {assoc} .
  op mi_ : ValSq -> Indicator  .
}

-- for generating all possible state configurations
-- by generating all possible combinations of values
-- for observers
mod GENcss (M :: MI){

  -- [Bit Nat SRch BNpair Nseq RSch Event < Val < ValSq]
  -- op _,_ : ValSq ValSq -> ValSq {assoc} .

  -- generating all argument combinations lazily
  -- value tree

  [Val < VlTr]
  op _;;_ : VlTr VlTr -> VlTr {r-assoc strat: (1 0)} .

  -- val or tree sequence
  [ValSq VlTr < VtSq]
  op _,_ : VtSq VtSq -> VtSq {assoc} .
  -- VtSq enclosure
  [VtSqEn < VtSqTr]
  op {_} : VtSq -> VtSqEn .
  -- tree of VtSqEn
  op _!!_ : VtSqTr VtSqTr -> VtSqTr {r-assoc strat: (1 0)} .

  -- first element
  op fst1_ : VlTr -> Val .
  eq fst1(VL:Val) = VL .
  eq fst1(VT1:VlTr ;; VT2:VlTr) = if (VT1 :is Val) then VT1 else fst1(VT1) fi .
  -- rest 
  op rst1_ : VlTr -> VlTr .
  eq rst1(VT1:VlTr ;; VT2:VlTr) = if (VT1 :is Val) then VT2 else (rst1(VT1) ;; VT2) fi .

  -- expansion
  ceq {VT1:VlTr,VTS2:VtSq} = {(fst1 VT1),VTS2} !! {(rst1 VT1),VTS2} 
  if not(VT1 :is Val) .
  ceq {VTS1:VtSq,VT2:VlTr} = {VTS1,(fst1 VT2)} !! {VTS1,(rst1 VT2)} 
  if not(VT2 :is Val) .
  ceq {VTS1:VtSq,VT2:VlTr,VTS3:VtSq} = {VTS1,(fst1 VT2),VTS3} !! {VTS1,(rst1 VT2),VTS3} 
  if not(VT2 :is Val) .

  -- first element
  op fst2_ : VtSqTr -> VtSqEn .
  eq fst2({VS:VtSq}) = {VS} .
  eq fst2(VST1:VtSqTr !! VST2:VtSqTr) 
  = if (VST1 :is VtSqEn) then VST1 else (fst2 VST1) fi .
  -- rest 
  op rst2_ : VtSqTr -> VtSqTr .
  eq rst2(VST1:VtSqTr !! VST2:VtSqTr) 
  = if (VST1 :is VtSqEn) then VST2 else ((rst2 VST1) !! VST2) fi .

  op getVsq_ : VtSqEn -> ValSq .
  --> (A)
  eq getVsq{VSQ:ValSq} = VSQ .

  pred true? : Indicator .
  eq true?(i(B:Bool,S:State,E:Event)) = (B == true) .

  -- check one by one 
  op $ : -> Indicator .
  op check1by1_ : VtSqTr -> Indicator .
  --> (B)
  eq check1by1{VSQ:ValSq} = (if true?(mi(VSQ)) then $ else mi(VSQ) fi) .
  --> (C)
  ceq check1by1(VST:VtSqTr) =
    (if true?(mi(getVsq(fst2(VST)))) then check1by1(rst2(VST)) 
     else mi(getVsq(fst2(VST))) fi)
  if not(VST :is VtSqEn) .
}

-- properties on SRCH
mod SRCHprop {
  pr(SRCH)

  vars BN1 BN2 : BNpair .
  var SRC : SRch .

  -- zero difference of elements
  pred zeroD : SRch .
  eq zeroD(empBN) = true .
  eq zeroD(BN1) = true .
  eq zeroD(BN1 BN2) = (BN1 = BN2) .
  eq zeroD(BN1 SRC BN2) = ((BN1 = BN2) and zeroD(BN1 SRC)) .

  -- at most one difference of elements
  pred oneD : SRch .
  eq oneD(empBN) = true .
  eq oneD(BN1) = true .
  eq oneD(BN1 BN2) = 
    if (BN1 = BN2) then true 
      else ((not(1st(BN1) = 1st(BN2)))
            and (2nd(BN1) = s(2nd(BN2)))) fi .
  eq oneD(BN1 SRC BN2) = 
    if (BN1 = BN2) then zeroD(BN1 SRC) 
  else (not(1st(BN1) = 1st(BN2))
	and (2nd(BN1) = s(2nd(BN2)))
	and oneD(BN1 SRC)) fi .

  vars B B1 B2 : Bit .
  vars N N1 N2 N3 : Nat .
  -- facts
  ceq zeroD(BN1 BN2 SRC) = false if not(BN1 = BN2) .

  eq (zeroD(bn(B,N) SRC) and (2nd(lhd(SRC bn(B,N))) = N))
  = zeroD(bn(B,N) SRC) . 
  eq (zeroD(bn(B,N) SRC) and (B = 1st(lhd(SRC bn(B,N)))))
  = zeroD(bn(B,N) SRC) . 

  eq (zeroD(bn(B,N) SRC) and (2nd(rhd(bn(B,N) SRC )) = N))
  = zeroD(bn(B,N) SRC) . 
  eq (zeroD(bn(B,N) SRC) and (B = 1st(rhd(bn(B,N) SRC))))
  = zeroD(bn(B,N) SRC) . 

  eq zeroD(SRC bn(B,N)) = zeroD(bn(B,N) SRC) .
  eq zeroD(bn(B,N) bn(B,N) SRC) = zeroD(bn(B,N) SRC) .

  eq (zeroD(bn(B,N) SRC) and oneD(bn(B,N) SRC)) = zeroD(bn(B,N) SRC) .

  ceq (zeroD(bn(B1,N1) SRC) and (B = 1st(lhd(SRC bn(B2,N2)))))
  = false if (B1 = not(B)) .

  eq (zeroD(bn(B1,N1) SRC) and (N = (s N1)) and 
	(N = (s 2nd(lhd(SRC bn(B2,N2))))))
  = (zeroD(bn(B1,N1) SRC) and (N = (s N1))) .

  --
  ceq oneD(bn(B1,N1) bn(B2,N2) SRC) = false 
    if ((B1 = B2) and not(N1 = N2)) .
  ceq oneD(bn(B1,N1) bn(B2,N2) SRC) = false 
    if (not(B1 = B2) and (N1 = N2)) .

  ceq (oneD(bn(B1,N1) bn(B2,N2) SRC) and (N1 = N3)) = false
    if not(N3 = (s N2)) .

  eq (oneD(bn(B1,N1) SRC) and (B1 = 1st(rhd(bn(B1,N1) SRC))))
  = zeroD(bn(B1,N1) SRC) .

  eq (zeroD(bn(b1,N2) SRC) and oneD(bn(b0,N1) bn(b1,N2) SRC))
  = zeroD(bn(b1,N2) SRC) .
  eq (zeroD(bn(b0,N2) SRC) and oneD(bn(b1,N1) bn(b0,N2) SRC))
  = zeroD(bn(b0,N2) SRC) .

  eq oneD(bn(B1,N1) bn(B1,N1) SRC) = oneD(bn(B1,N1) SRC) .

  eq (zeroD(bn(b1,N2) SRC) and oneD(bn(b0,N1) SRC) and (N1 = s N2))
  = (zeroD(bn(b1,N2) SRC) and (N1 = s N2)) .
  eq (zeroD(bn(b0,N2) SRC) and oneD(bn(b1,N1) SRC) and (N1 = s N2))
  = (zeroD(bn(b0,N2) SRC) and (N1 = s N2)) .

  eq (oneD(SRC bn(b1,N2)) and oneD(bn(b0,N1) SRC) and (N1 = s N2))
  = (oneD(bn(b0,N1) SRC) and (N1 = s N2)) .
  eq (oneD(SRC bn(b0,N2)) and oneD(bn(b1,N1) SRC) and (N1 = s N2))
  = (oneD(bn(b1,N1) SRC) and (N1 = s N2)) .

  ceq (zeroD(bn(B2,N2) SRC) and (N1 = (s N2)) 
       and oneD(bn(B1,N1) bn(B2,N2) SRC)) 
  = (zeroD(bn(B2,N2) SRC) and (N1 = (s N2)))
  if not(B1 = B2) .

  eq (oneD(bn(B1,N1) bn(B2,N2) SRC) and (N1 = (s N2)))
  = (zeroD(bn(B2,N2) SRC) and (N1 = (s N2))) .

  --

  ceq (oneD(bn(B1,N1) SRC) and 
	 (1st(lhd(SRC bn(B2,N2))) = B1) and
	   (2nd(lhd(SRC bn(B2,N2))) = (s N2)))
  = (oneD(bn(B1,N1) SRC) and 
       (1st(lhd(SRC bn(B2,N2))) = B1)) if (B2 = not(B1)) .
  ceq (oneD(bn(B1,N1) SRC) and 
	 (1st(lhd(SRC bn(B2,N2))) = B1) and
	   (2nd(lhd(SRC bn(B2,N2))) = N1))
  = (oneD(bn(B1,N1) SRC) and 
       (1st(lhd(SRC bn(B2,N2))) = B1)) if (B2 = not(B1)) .

  ceq (oneD(bn(B1,N1) SRC) and 
	 (1st(lhd(SRC bn(B2,N2))) = B2) and
	   ((s 2nd(lhd(SRC bn(B2,N2)))) = N1))
  = (oneD(bn(B1,N1) SRC) and 
       (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .

  ceq (oneD(bn(B1,N1) SRC) and
	 (2nd(lhd(SRC bn(B2,N2))) = N2) and
	   (1st(lhd(SRC bn(B2,N2))) = B2))
  = (oneD(bn(B1,N1) SRC) and
       (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .
  -- the following equation can be loaded into this module!! 121026
  -- strange phenomena!! 
  -- ceq (oneD(bn(B1,N1) SRC) and
  --     (1st(lhd(SRC bn(B2,N2))) = B2) and
  --     (2nd(lhd(SRC bn(B2,N2))) = N2))
  --     = (oneD(bn(B1,N1) SRC) and
  --        (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .
}

-- properties on RSCH
mod RSCHprop {
  pr(RSCH)

  -- zero change of elements
  pred zeroC : RSch .
  eq zeroC(empB) = true .
  eq zeroC(B:Bit) = true .
  eq zeroC(B1:Bit B2:Bit) = (B1 = B2) .
  eq zeroC(B1:Bit RSC:RSch B2:Bit) = ((B1 = B2) and zeroC(B1 RSC)) .

  -- at most one change of elements
  pred oneC : RSch .
  eq oneC(empB) = true .
  eq oneC(B:Bit) = true .
  eq oneC(B1:Bit B2:Bit) = true .
  eq oneC(B1:Bit RSC:RSch B2:Bit) = 
    if (B1 = B2) then zeroC(B1 RSC) else oneC(B1 RSC) fi .

  -- proved properties
  --> zero-p1
  ceq zeroC(B1:Bit B2:Bit RSC:RSch) = false if not(B1 = B2) .
  --> zero-p2
  eq zeroC(B:Bit B RSC:RSch) = zeroC(B RSC) .
  --> zero-p3
  eq zeroC(RSC:RSch B:Bit) = zeroC(B RSC) .
  --> zero-p4
  eq (zeroC(B:Bit RSC:RSch) and zeroC(RSC)) = zeroC(B RSC) .
  --> zero-p5
  eq (zeroC(B1:Bit RSC:RSch) and (rhd(B1 RSC) = B1)) = (zeroC(B1 RSC)) .

  --> one-p1
  eq oneC(B1:Bit B1 RSC:RSch) = oneC(B1 RSC) .
  --> one-p2
  ceq oneC(B1:Bit B2:Bit RSC:RSch) = zeroC(B2 RSC) if not(B1 = B2) .
  --> one-p3
  eq oneC(RSC:RSch B:Bit) = oneC((not(B)) RSC) .
  --> one-p4
  eq (zeroC(B1:Bit RSC:RSch) and oneC(B1 RSC)) = zeroC(B1 RSC) .
  --> one-p5
  eq (oneC(B:Bit RSC:RSch) and oneC(RSC)) = oneC(B RSC) .
  --> one-p6
  eq (zeroC(RSC:RSch) and oneC(RSC)) = zeroC(RSC) .
  --> one-p7
  eq (zeroC(B:Bit RSC:RSch) and oneC(RSC)) = zeroC(B RSC) .

  --> one-p-11
  eq oneC(RSC1:RSch B:Bit B RSC2:RSch) = oneC(RSC1 B RSC2) .
  --> one-p-12
  eq (oneC(RSC1:RSch B:Bit RSC2:RSch) and oneC(RSC1 RSC2)) = oneC(RSC1 B RSC2) .
}

-- ABP with predicates for invariant formation
mod* ABPprop {
  pr(ABP)
  pr(SRCHprop)
  pr(RSCHprop)
  --
  vars B B1 B2 Bs Br : Bit .
  var N : Nat .
  vars SRC SRC1 SRC2 : SRch .
  var BNP : BNpair .
  var NS : Nseq .
  vars RSC RSC1 RSC2 : RSch .
  var S : State .
  -- (sBit: Bs)(sNum: N)(srCh: SRC)(rBit: Br)(rNums: Nseq)(rsCh: RSC)
  -- p1,p2,... are possible fragments of the invariant predicate

  -- the supposed functionality of ABP protocol
  op p1 : State -> Bool .
  eq[p1]: p1((sBit: Bs)(sNum: N)(rBit: Br)(rNums: NS) S)
             = ((Bs = Br) implies (mk(N) = (N NS))) and
               (not(Bs = Br) implies (mk(N) = NS)) .

}

mod CHKcss (TS :: TPP) {
  pr(GENcss(INDppp(PPP(TS))))

  -- facts about Bit
  eq ((b0 = B:Bit) and (b1 = B)) = false .
  eq ((Bo:Bool and (B1:Bit = b0)) xor (Bo and (B1 = b1))) = Bo .

  -- facts about nat
  ceq ((N1:Nat = N2:Nat) and (N1 = N3:Nat)) = false 
    if not(N2 = N3) .
}

-- eof

-- (1)
open (CHKcss(ABPprop{op pre -> p1,op post -> p1})) .
ops bv1 bv2 : -> Bit .
op nv : -> Nat .
ops src : -> SRch .
op ns : -> Nseq .
ops rsc : -> RSch .
--> okay for ss and rs
red check1by1{bv1,nv,src,bv2,ns,rsc,(ss ;; rs)} .
close

-- (2)
open (CHKcss(ABPprop{op pre -> p1,op post -> p1})) .
ops bv1 bv2 bv3 : -> Bit .
ops nv1 nv2 : -> Nat .
ops src1 src2 : -> SRch .
op ns : -> Nseq .
op rsc : -> RSch .
-- set debug rewrite on
red check1by1{bv1,nv1,
	      (empBN ;; bn(bv2,nv2) ;; (src1 bn(bv2,nv2)) ;; (bn(bv2,nv2) src2) ;;
		 (src1 bn(bv2,nv2) src2)), bv3,ns,rsc, (drSr ;; duSr)} .

-- set trace whole on
-- set trace on
-- evq (setq **sa-debug** t)
**> =======================================
-- set debug rewrite on 
red (if true?((mi (getVsq ({ ((bv1 , nv1) , ((src1 (bn(bv2,nv2) src2)) , (bv3 , (ns , (rsc , drSr))))) })))) then (check1by1 (rst2 (({ ((bv1 , nv1) , ((src1 (bn(bv2,nv2) src2)) , (bv3 , (ns , (rsc , drSr))))) }) !! ({ ((bv1 , (nv1 , ((empBN ; ; (bn(bv2,nv2) ; ; ((src1 bn(bv2,nv2)) ; ; ((bn(bv2,nv2) src2) ; ; (src1 (bn(bv2,nv2) src2)))))) , (bv3 , (ns , rsc))))) , (rst1 (drSr ; ; duSr))) })))) else (mi (getVsq (fst2 (({ ((bv1 , nv1) , ((src1 (bn(bv2,nv2) src2)) , (bv3 , (ns , (rsc , drSr))))) }) !! ({ ((bv1 , (nv1 , ((empBN ; ; (bn(bv2,nv2) ; ; ((src1 bn(bv2,nv2)) ; ; ((bn(bv2,nv2) src2) ; ; (src1 (bn(bv2,nv2) src2)))))) , (bv3 , (ns , rsc))))) , (rst1 (drSr ; ; duSr))) }))))) fi) .
set debug rewrite off
evq (setq t0 $$term)
evq (setq t0 (term-arg-1(term-arg-1(term-arg-1(term-arg-1(term-arg-1 t0))))))

eof

-- set trace whole off
set trace off
evq (setq term $$term)
set verbose on
show tree
-- evq (setq **sa-debug** nil)
**> ======================================
parse (check1by1 ({ ((bv1 , nv1) , ((src1 (bn(bv2,nv2) src2)) , (bv3 , (ns , (rsc , duSr))))) })) .
evq (setq term2 $$term)
show tree
set verbose off

eof

close

