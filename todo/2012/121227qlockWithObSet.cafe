-- 
-- specification and proof score for QLOCK
-- with states modeled as sets of observers
--

-- labels for indicating location of each process
mod! LABEL {
-- literal labels and labels
[LabelLt < Label]
-- rs: remainder section
-- ws: waiting section
-- cs: critical section
ops rs ws cs : -> LabelLt {constr} .
eq (L1:LabelLt = L2:LabelLt) = (L1 == L2) .
}

-- process identifiers
mod* PID {
-- literal process identifiers 
-- and process identifiers
[PidLt < Pid]
-- PidLt denotes pid literal 
eq (P1:PidLt = P2:PidLt) = (P1 == P2) .
}

-- queue (First In First Out storage)
-- for storing process identifiers
mod! QUEUE (X :: TRIV) {
[Elt < Qu]
-- empty queue
op emp : -> Qu . 
-- assoicative queue constructor with id: emp
op (_&_) : Qu Qu -> Qu {constr assoc id: emp} .
-- equality _=_ over Qu
eq (emp = (E:Elt & Q:Qu)) = false .
eq (E1:Elt = (E21:Elt & E22:Elt & Q2:Qu)) = false .
-- equality over seq of length more than 1
eq ((E11:Elt & E12:Elt & Q1:Qu) = (E21:Elt & E22:Elt & Q2:Qu)) 
     = ((E11 = E21) and (E12 = E22) and (Q1 = Q2)) .
-- "eq ((E1:Elt & Q1:Qu) = (E2:Elt & Q2:Qu)) = ((E1 = E2) and (Q1 = Q2)) ."
-- can not be declared because it induces an infinite loop eq 
-- "eq (E1:Elt = E2:Elt) = (E1 = E2) ."
-- by taking Q1 as emp and Q2 as emp

-- hd
op hd : Qu -> Elt .
eq hd(E:Elt & Q:Qu) = E .
-- (hd(E:Elt) = E .) is induced from the above eq

-- tl
op tl : Qu -> Qu .
eq tl(E:Elt & Q:Qu) = Q .
-- (eq [compl3]: hd(E:Elt) = E .) is induced from the above eq

-- assertions about hd on emp
ceq (hd(emp) = E:Elt) = false if not(E == hd(emp)) .

}

-- a state is defined as a set of observers
mod! STATE {
pr(LABEL)
pr(QUEUE(PID{sort Elt -> Pid}))
[Obs < State]
-- a state configuration defined as a set of observers
op (_ _) : State State -> State {comm assoc}
-- (_ _) is idempotent
eq S:State S = S .
-- there are two kinds of obserbers
op (qu:_ ) : Qu -> Obs {constr} .
op (pc[_]:_) : Pid Label -> Obs {constr} .
}

-- QLOCK (mutual exclusion protocol with queue of pids) 
-- defined as a mono-action OTS (observational transition system)
mod* QLOCK {
pr(STATE)
[Pid < Event]
-- the action
op trans : State Event -> State .
var Q : Qu .
var L : Label .
vars P P1 P2 : Pid .
var S : State .
-- wt : want, L = rs
eq[wt]: trans(((qu: Q)(pc[P1]: rs) S),P2) 
         = (if (P1 = P2) then ((qu: (Q & P1))(pc[P1]: ws) S)
                         else ((qu: Q)(pc[P1]: rs) S) fi) .
-- ty : try, L = ws
eq[ty]: trans(((qu: Q)(pc[P1]: ws) S),P2)
         = if (hd(Q) = P1) and (P1 = P2)
           then ((qu: Q)(pc[P1]: cs) S)
           else ((qu: Q)(pc[P1]: ws) S) fi .

-- ex : exit, L = cs ; different from the original definition
eq[ex]: trans((qu: Q)(pc[P1]: cs) S,P2)
         = if (hd(Q) = P1) and (P1 = P2)
           then ((qu: tl(Q))(pc[P1]: rs) S)
           else ((qu: Q)(pc[P1]: cs) S) fi .
}

-- predicates about QLOCK
mod* QLOCKprop {
pr(NAT)  
pr(QLOCK) 
--
var L : Label .
vars P P1 : Pid .
var B : Bool .
var S : State .
var Q : Qu .
-- the number of processes with the label cs
op #cs : State -> Nat .
eq #cs((qu: Q) S) = #cs(S) .
eq #cs((pc[P]: L) S) = 
   if (L = cs) then 1 + #cs(S) else #cs(S) fi .
-- mutual exclusion property: only one process is with the label cs
pred m : State  .
eq[m]: m(S) = #cs(S) < 2 .
-- other predicats, i.e. faragments for invariant(s)
-- in this case only one is enough
op p1 : State -> Bool .
eq[p1]: p1((qu: Q)(pc[P1]: L) S) =
        ((Q = emp) implies (#cs(S) < 1)) and
        (not(Q = emp) implies 
           (((L = cs) implies 
              ((P1 = hd(Q)) and (#cs(S) < 1) 
                            and not(hd(tl(Q)) = P1))) and 
            ((L = ws) implies 
              ((P1 = hd(Q)) implies 
               ((#cs(S) < 1) and not(hd(tl(Q)) = P1)))) and 
            ((L = rs) implies (not(P1 = hd(Q)))))) .
--
op m+p1 : State -> Bool .
eq m+p1(S) = (m(S) and p1(S)) .
}

-- a theory for transition systems 
-- with Pre and Post Predicates
mod* TPP {
[State Event]
op trans : State Event -> State .
op pre : State -> Bool .
op post : State -> Bool .
}

-- defining the pre-post predicate for a TPP
mod* PPP (TS :: TPP) {
op ppp : State Event -> Bool .
eq ppp(S:State,P:Event) = pre(S) implies post(trans(S,P)) .
}

-- a theory for transition systems
-- with a pre-post predicate
mod* TPPP {
pr(QLOCK)
op ppp : State Event -> Bool .
}

-- for indicating the pre-post predicate 
-- for a state configuration of QLOCK
mod* INDppp (TS :: TPPP) {

-- for defining a list of arguments 
-- or a sequence of Vals for the operator mi_
[Qu Pid Label Event State < Val < ValSq]
-- constructor of sequences of Val
op _,_ : ValSq ValSq -> ValSq {constr assoc} .

[Indicator]
-- the first argument shows whether the ppp (pre-post predate)
-- holds for the state that is described 
-- by the state configuration in the second argument and
-- the next state brought by the third argument
op i : Bool State Event -> Indicator {constr} .

-- make indicators for QLOCK
op mi_ : ValSq -> Indicator  .
eq mi(Q:Qu,P1:Pid,L:Label,S:State,P2:Event)
     = i(ppp(((qu: Q)(pc[P1]: L) S),P2),((qu: Q)(pc[P1]: L) S),P2) .
}

-- a theory for QLOCK transition system
-- with i (indicator) and mi_ (make indicators)
mod* MI {
pr(QLOCK)
[Val < ValSq, Indicator]
op i : Bool State Event -> Indicator {constr} .
op mi_ : ValSq -> Indicator  .
}

-- for generating all necessary cases
-- by expanding the argument sequences
mod* GENcss (M :: MI){

-- sequences of Val for generating cases
[Val < VlSq]
op _;_ : VlSq VlSq -> VlSq {assoc} .
-- sequences of ValSeq or ValSq
[VlSq ValSq < SqSq]
-- op empty : -> SqSq .
-- op _,_ : SqSq SqSq -> SqSq {assoc id: empty} .
op _,_ : SqSq SqSq -> SqSq {assoc} .

-- for generating all argument combinations
op [_] : SqSq -> SqSq .
op _||_ : SqSq SqSq -> SqSq .
var V : Val .
var VS : VlSq .
vars SS SS1 SS2 : SqSq .
eq [((V ; VS),SS2)] = [(V,SS2)] || [(VS,SS2)] .
eq [(SS1,(V ; VS),SS2)] = [(SS1,V,SS2)] || [(SS1,VS,SS2)] .
eq [(SS1,(V ; VS))] = [(SS1,V)] || [(SS1,VS)] .

-- sequences of indicators
op $ : -> Indicator .
op _|_ : Indicator Indicator -> Indicator .

-- translating sequences of cases (sequences of arguments(Vals))
-- into sequences of indicators
op mmi_ : SqSq -> Indicator .
eq mmi(SS1 || SS2) = (mmi SS1) | (mmi SS2) .

-- if all _;_ in SqSq disappears 
-- then translate mmi to mi
eq mmi[VSQ:ValSq] = mi(VSQ) .

-- making all indicators with true in the first argument disappear 
var I : Indicator .  var S : State . var E : Event .
eq i(true,S,E) | I = I .
eq I | i(true,S,E) = I .

}

-- facts to be used
mod* FACTtbu {
  pr(NAT)
  -- necessary facts about _<_
  var N : Nat .
  vars NZ1 NZ2 : NzNat .
  eq (NZ1 + N < NZ2) = (N < sd(NZ1,NZ2)) .
  ceq ((N < NZ1) and (N < NZ2)) = (N < NZ1) if (NZ1 <= NZ2) .
}

--
-- checking all possible cases
--
open (GENcss(INDppp(PPP(QLOCKprop{op pre -> m+p1,op post -> m+p1})))) .
pr(FACTtbu)
ops r1 r2 r3 : -> PidLt .
op q : -> Qu .
op s : -> State .
red ($ | mmi[(emp ; r1 ; (r1 & q)),
             (r1 ; r2),
             (rs ; ws ; cs),
             s,
             (r1 ; r2 ; r3)]) .
close

--> ***QED***
