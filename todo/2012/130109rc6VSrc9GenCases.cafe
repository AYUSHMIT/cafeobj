-- 
-- specification and proof score for ABP
--  (Alternating Bit Protocol)
-- with states modeled as sets of observers
--

-- bits (2 elemnts) for alternation
mod! BIT {
 [BitLt < Bit]
 ops b0 b1 : -> BitLt .
 eq (B1:BitLt = B2:BitLt) = (B1 == B2) .
 op not : Bit -> Bit .
 eq not(b0) = b1 .
 eq not(b1) = b0 .
 eq (B:Bit = not(B)) = false .
}

-- natural numbers in Peano style
mod! NNUM {
 [NzNat NatLt < Nat]
 op 0 : -> Nat .
 op s_ : Nat -> NzNat .
 op p_ : NzNat -> Nat .
 eq (p (s N:Nat)) = N .
 eq (0 = 0) = true .
 eq (0 = s N:Nat) = false .
 eq (s N1:Nat = s N2:Nat) = (N1 = N2) .
 --
 eq (N1:NatLt = N2:NatLt) = (N1 == N2) .
 -- facts
 eq (N:Nat = (s N)) = false .
}

-- pair of bit and natural number
mod! BN-PAIR{
 pr(BIT + NNUM)
 [BNpair]
 op bn : Bit Nat -> BNpair .
 eq (bn(B1:Bit,N1:Nat) = bn(B2:Bit,N2:Nat))
    = (B1 = B2) and (N1 = N2) .
 op 1st : BNpair -> Bit .
 eq 1st(bn(B:Bit,N:Nat)) = B .
 op 2nd : BNpair -> Nat .
 eq 2nd(bn(B:Bit,N:Nat)) = N .
}

mod* TRIV= {
[Elt]
pred _=_ : Elt Elt {comm}.
eq (E:Elt = E) = true .
}

-- Sequence without {id: emp}
mod* SEQ (X :: TRIV=) {
[Elt < Seq]
-- empty Sequence
op emp : -> Seq . 
op (_ _) : Seq Seq -> Seq {constr assoc}
eq (emp S:Seq) = S .
eq (S:Seq emp) = S .
--
eq (emp = E:Elt) = false .
eq (emp = (E:Elt S:Seq)) = false .
eq (emp = (S:Seq E:Elt)) = false .
eq (E1:Elt = (E21:Elt E22:Elt)) = false .
eq (E1:Elt = (E21:Elt E22:Elt S2:Seq)) = false .
eq (E1:Elt = (S1:Seq E21:Elt E22:Elt)) = false .
eq ((E11:Elt E12:Elt) = (E21:Elt E22:Elt))
     = ((E11 = E21) and (E12 = E22)) .
eq ((E11:Elt E12:Elt) = (E21:Elt E22:Elt S2:Seq))
     = ((E11 = E21) and (E12 = E22) and (emp = S2)) .
eq ((E11:Elt E12:Elt S1:Seq) = (E21:Elt E22:Elt S2:Seq))
     = ((E11 = E21) and (E12 = E22) and (S1 = S2)) .
--
-- left hd and right tail
op lhd : Seq -> Elt .
eq lhd(E:Elt) = E .
eq lhd(E:Elt S:Seq) = E .
--
op rtl : Seq -> Seq .
eq rtl(E:Elt) = emp .
eq rtl(E:Elt S:Seq) = S .
--
op rhd : Seq -> Elt .
eq rhd(E:Elt) = E .
eq rhd(S:Seq E:Elt) = E .
--
op ltl : Seq -> Seq .
eq ltl(E:Elt) = emp .
eq ltl(S:Seq E:Elt) = S .

-- facts, or assertions about operations on emp
eq (lhd(emp) = E:Elt) = false .
eq (rhd(emp) = E:Elt) = false .
ceq (S:Seq = emp) = false if (lhd(S) = E:Elt) .
ceq (S:Seq = emp) = false if (rhd(S) = E:Elt) .
eq ((E:Elt S1:Seq) = (E S2:Seq)) = (S1 = S2) .

-- facts: assertions about ops on emp
eq (lhd(emp) = E:Elt) = false .
eq (rhd(emp) = E:Elt) = false .
eq ((S:Seq = emp) and (lhd(S) = E:Elt)) = false .
eq ((S:Seq = emp) and (rhd(S) = E:Elt)) = false .

eq ((S1:Seq = S2:Seq) and (S1 = (E:Elt S3:Seq S2))) = false .
eq ((S1:Seq = (E1:Elt S2:Seq)) and ((E2:Elt S1) = S2)) = false .

}

mod! NUM-SEQ{
 pr(SEQ(NNUM{sort Elt -> Nat,
             op (E1:Elt = E2:Elt) -> (E1:Nat = E2:Nat)})
    *{sort Seq -> Nseq,op emp -> empN})

-- new def of mk 121001
-- pseudo Nat
-- [Nat < PNat]
-- op mk : Nat -> Nseq .
-- op pre : Nat -> PNat .
-- eq mk(N:Nat) = (N mk(pre(N))) .
-- eq pre(NN:NzNat) = p(NN) .
-- eq mk(pre(0)) = empN .

-- original definition
op mk : Nat -> Nseq .
eq mk(0) = (0 empN) .
eq mk(N:NzNat) = (N mk(p(N))) .

-- fact for ABP 121001: this fact does not hold!
-- to make the following effective 
-- the new definition of mk is prepared
--   eq ((mk(N:Nat) = (N1:Nat NS:Nseq)) and (mk(N) = (N2:Nat NS))) 
--     = ((N1 = N2) and (N = N1)) .

-- fact 121002
ceq (mk(N1:Nat) = (N2:Nat NS:Nseq)) = false if not(N1 = N2) .
}

-- 121001 the system says that
-- the following causes the sort name Nseq ambiguous??
-- pr(SEQ(NUM-SEQ{sort Elt -> Nseq})
--   *{sort Seq -> NseqSq,
--     op (_ _) -> (_;_)})

-- receiver to sender channel
mod! RSCH {
  pr(SEQ(BIT{sort Elt -> Bit
             op (E1:Elt = E2:Elt) -> (E1:Bit = E2:Bit)})
     *{sort Seq -> RSch, op emp -> empB})}

-- Sender-receiver channel: sequence of Bit-Nat pairs
mod! SRCH {
  pr(SEQ(BN-PAIR{sort Elt -> BNpair
                 op (E1:Elt = E2:Elt) -> (E1:BNpair = E2:BNpair)})
     *{sort Seq -> SRch,op emp -> empBN})
}

-- a state is defined as a set of observers
mod* STATE {
  pr(SRCH)
  pr(NUM-SEQ)
  pr(RSCH)
  -- state is a set of observers
  [Obs < State]
  -- state constructor
  op _ _ : State State -> State {constr assoc comm idem}
  -- 6 kinds of observers
  op (sBit:_) : Bit -> Obs {constr}   -- Sender's bit
  op (sNum:_) : Nat -> Obs {constr}   -- the number Sender wants to deliver 
  op (srCh:_) : SRch -> Obs {constr}  -- Sender-to-Receiver channel
  op (rBit:_) : Bit -> Obs {constr}   -- Receiver's bit
  op (rNums:_) : Nseq -> Obs {constr} -- the sequence of numbers received by Receiver
  op (rsCh:_) : RSch -> Obs {constr}  -- Receiver-to-Sender channel
}

-- events that cause state transitions
mod! EVENT {
 [EventLt < Event]
 ops ss drSr duSr rr rs drRs duRs sr : -> EventLt .
 eq (E1:EventLt = E2:EventLt) = (E1 == E2) .
}

-- ABP (alternating bit protocol) 
mod* ABP {
  pr(STATE)
  pr(EVENT)
  op trans : State Event -> State .
  -- 
  var S : State .
  vars B Bs Br : Bit .
  var N : Nat .
  vars SRC SRC1 SRC2 : SRch .
  var BNP : BNpair .
  var NS : Nseq .
  vars RSC RSC1 RSC2 : RSch .

  -- (sBit: Bs)(sNum: N)(srCh: SRC)(rBit: Br)(rNums: Nseq)(rsCh: RSC)
  -- ( and ) enclosing if_the_else_fi is needed in a ceq
  -- datum is getting through all the Sequences from left to right

  -- Sender's sending a bit-number pair through srCh
  -- srCh : sender to receiver channel
  eq[ss]: trans(((sBit: Bs)(sNum: N)(srCh: SRC) S), ss)
          = ((sBit: Bs)(sNum: N)(srCh: (bn(Bs,N) SRC)) S) .
  -- for selecting dropping or duplication point non-deterministically
  -- is it needed?121020
  -- ops x-sr y-sr : SRch -> SRch .
  -- data drop from srCh
  eq[drSr1]: trans((srCh: empBN) S, drSr) = ((srCh: empBN) S) .
  eq[drSr2]: trans((srCh: BNP) S, drSr) = ((srCh: empBN) S) .
  eq[drSr3]: trans((srCh: (BNP SRC2)) S, drSr) = ((srCh: (SRC2)) S) .
  eq[drSr4]: trans((srCh: (SRC1 BNP)) S, drSr) = ((srCh: (SRC1)) S) .
  eq[drSr5]: trans((srCh: (SRC1 BNP SRC2)) S, drSr) = ((srCh: (SRC1 SRC2)) S) .
  -- data duplication in srCh
  eq[duSr1]: trans((srCh: empBN) S, duSr) = ((srCh: empBN)S) .
  eq[duSr2]: trans((srCh: BNP) S, duSr) = ((srCh: (BNP BNP)) S) .
  eq[duSr3]: trans((srCh: (SRC1 BNP)) S, duSr) = ((srCh: (SRC1 BNP BNP)) S) .
  eq[duSr4]: trans((srCh: (BNP SRC2)) S, duSr) = ((srCh: (BNP BNP SRC2)) S) .
  eq[duSr5]: trans((srCh: (SRC1 BNP SRC2)) S, duSr) = ((srCh: (SRC1 BNP BNP SRC2)) S) .
  -- Receiver's receiving a bit number pair from srCh
  eq[rr1]: trans(((srCh: empBN)(rBit: Br)(rNums: NS) S), rr)
           = ((srCh: empBN)(rBit: Br)(rNums: NS) S) .
  eq[rr2]: trans(((srCh: BNP)(rBit: Br)(rNums: NS) S), rr)
           = if (1st(BNP) = Br) 
             then ((srCh: empBN)(rBit: not(Br))(rNums: (2nd(BNP) NS)) S)
             else ((srCh: empBN)(rBit: Br)(rNums: NS) S) fi .
  eq[rr3]: trans(((srCh: (SRC BNP))(rBit: Br)(rNums: NS) S), rr)
           = if (1st(BNP) = Br) 
             then ((srCh: SRC)(rBit: not(Br))(rNums: (2nd(BNP) NS)) S)
             else ((srCh: SRC)(rBit: Br)(rNums: NS) S) fi .
  -- Receiver's sending a bit number to rsCh
  -- rsCh : receiver to sender channel
  eq[rs]: trans(((rBit: Br)(rsCh: RSC) S), rs) = ((rBit: Br)(rsCh: (Br RSC)) S) .
  -- data drop from rsCh
  eq[drRs1]: trans((rsCh: empB) S, drRs) = ((rsCh: empB) S) .
  eq[drRs2]: trans((rsCh: B) S, drRs) = ((rsCh: empB) S) .
  eq[drRs3]: trans((rsCh: (RSC1 B)) S, drRs) = ((rsCh: (RSC1)) S) .
  eq[drRs4]: trans((rsCh: (B RSC2)) S, drRs) = ((rsCh: (RSC2)) S) .
  eq[drRs5]: trans((rsCh: (RSC1 B RSC2)) S, drRs) = ((rsCh: (RSC1 RSC2)) S) .
  -- data duplication in rsCh
  eq[duRs1]: trans((rsCh: empB) S, duRs) = ((rsCh: empB)S) .
  eq[duRs2]: trans((rsCh: B) S, duRs) = ((rsCh: (B B)) S) .
  eq[duRs3]: trans((rsCh: (RSC1 B)) S, duRs) = ((rsCh: (RSC1 B B)) S) .
  eq[duRs4]: trans((rsCh: (B RSC2)) S, duRs) = ((rsCh: (B B RSC2)) S) .
  eq[duRs5]: trans((rsCh: (RSC1 B RSC2)) S, duRs) = ((rsCh: (RSC1 B B RSC2)) S) .
  -- Sender's receiving an ack (a bit)
  eq[sr1]: trans((rsCh: empB)(sBit: Bs)(sNum: N) S, sr)
          = ((rsCh: empB)(sBit: Bs)(sNum: N) S) .
  eq[sr2]: trans(((rsCh: B)(sBit: Bs)(sNum: N) S), sr)
          = if (B = Bs) 
            then ((rsCh: empB)(sBit: Bs)(sNum: N) S)
            else ((rsCh: empB)(sBit: B)(sNum: (s N)) S) fi .
  eq[sr3]: trans((rsCh: (RSC B))(sBit: Bs)(sNum: N) S, sr)
          = if (B = Bs) 
            then ((rsCh: RSC)(sBit: Bs)(sNum: N) S)
            else ((rsCh: RSC)(sBit: B)(sNum: (s N)) S) fi .
}

--
-- start of proof score for ABP
--

-- a theory for transition system with Pre and Post Predicates
mod* TPP {
 pr(ABP)
  op pre : State -> Bool .
  op post : State -> Bool .
}

-- defining the pre-post predicate for a TPP
mod PPP (TS :: TPP) {
 pr(ABP)
  op ppp : State Event -> Bool .
  eq ppp(S:State,E:Event) = pre(S) implies post(trans(S,E)) .
}

-- formal parameter module for ABP (a transition system)
-- with a pre-post predicate
mod* TPPP {
  pr(ABP)
  op ppp : State Event -> Bool .
}

-- for indicating the pre-post predicate 
-- for a specific state 
mod INDppp (TS :: TPPP) {
pr(ABP)

[Indicator]
-- the first argument show whether the ppp holds for
-- the state that is described by a state configuration
-- in the second argument
op i : Bool State Event -> Indicator {constr} .

-- for defining a list of arguments for 
-- operator mi_
[Bit Nat SRch BNpair Nseq RSch Event < Val < ValSq]
op _,_ : ValSq ValSq -> ValSq {assoc} .

-- make indicators: it is specific to ABP
op mi_ : ValSq -> Indicator  .
-- notice that this following rules can apply 
-- only after the generation rules defined in the module GEN- below apply
-- and all the arguments become Val element
eq mi(Bs:Bit,N:Nat,SRC:SRch,Br:Bit,NS:Nseq,RSC:RSch,E:Event)
     = i(ppp(((sBit: Bs)(sNum: N)(srCh: SRC)
              (rBit: Br)(rNums: NS)(rsCh: RSC)),E),
             ((sBit: Bs)(sNum: N)(srCh: SRC)
              (rBit: Br)(rNums: NS)(rsCh: RSC)),
              E) .
}

-- a theory with i and mi_
mod* MI {
[State, Event, Val < ValSq, Indicator]
op i : Bool State Event -> Indicator {constr} .
op mi_ : ValSq -> Indicator  .
}

-- for generating all possible state configurations
-- by generating all possible combinations of values
-- for observers
mod GENcss (M :: MI){

-- sequences of Val for generating cases
[Val < VlSq]
op _;_ : VlSq VlSq -> VlSq {assoc} .
[VlSq ValSq < SqSq]
op _,_ : SqSq SqSq -> SqSq {assoc} .

-- for expanding all argument combinations
op [_] : SqSq -> SqSq .
op _||_ : SqSq SqSq -> SqSq .
var V : Val .
var VS : VlSq .
vars SS SS1 SS2 : SqSq .
eq [((V ; VS),SS2)] = [(V,SS2)] || [(VS,SS2)] .
eq [(SS1,(V ; VS),SS2)] = [(SS1,V,SS2)] || [(SS1,VS,SS2)] .
eq [(SS1,(V ; VS))] = [(SS1,V)] || [(SS1,VS)] .

-- sequences of indicators
op $ : -> Indicator .
op _|_ : Indicator Indicator -> Indicator .

-- translating sequences of cases (sequences of arguments(Vals))
-- into sequences of indicators
op mmi_ : SqSq -> Indicator .
eq mmi(SS1 || SS2) = (mmi SS1) | (mmi SS2) .

-- if all _;_ in SqSq disappears 
-- then translate mmi to mi
eq mmi[VSQ:ValSq] = mi(VSQ) .

-- to make all indicators with "true" disappear 
var I : Indicator .  var S : State . var E : Event .
eq i(true,S,E) | I = I .
eq I | i(true,S,E) = I .

}

-- properties on SRCH
mod SRCHprop {
pr(SRCH)

vars BN1 BN2 : BNpair .
var SRC : SRch .

-- zero difference of elements
pred zeroD : SRch .
eq zeroD(empBN) = true .
eq zeroD(BN1) = true .
eq zeroD(BN1 BN2) = (BN1 = BN2) .
eq zeroD(BN1 SRC BN2) = ((BN1 = BN2) and zeroD(BN1 SRC)) .

-- at most one difference of elements
pred oneD : SRch .
eq oneD(empBN) = true .
eq oneD(BN1) = true .
eq oneD(BN1 BN2) = 
     if (BN1 = BN2) then true 
     else ((not(1st(BN1) = 1st(BN2)))
            and (2nd(BN1) = s(2nd(BN2)))) fi .
eq oneD(BN1 SRC BN2) = 
     if (BN1 = BN2) then zeroD(BN1 SRC) 
     else (not(1st(BN1) = 1st(BN2))
           and (2nd(BN1) = s(2nd(BN2)))
           and oneD(BN1 SRC)) fi .

vars B B1 B2 : Bit .
vars N N1 N2 N3 : Nat .
-- facts
ceq zeroD(BN1 BN2 SRC) = false if not(BN1 = BN2) .

eq (zeroD(bn(B,N) SRC) and (2nd(lhd(SRC bn(B,N))) = N))
    = zeroD(bn(B,N) SRC) . 
eq (zeroD(bn(B,N) SRC) and (B = 1st(lhd(SRC bn(B,N)))))
    = zeroD(bn(B,N) SRC) . 

eq (zeroD(bn(B,N) SRC) and (2nd(rhd(bn(B,N) SRC )) = N))
    = zeroD(bn(B,N) SRC) . 
eq (zeroD(bn(B,N) SRC) and (B = 1st(rhd(bn(B,N) SRC))))
    = zeroD(bn(B,N) SRC) . 

eq zeroD(SRC bn(B,N)) = zeroD(bn(B,N) SRC) .
eq zeroD(bn(B,N) bn(B,N) SRC) = zeroD(bn(B,N) SRC) .

eq (zeroD(bn(B,N) SRC) and oneD(bn(B,N) SRC)) = zeroD(bn(B,N) SRC) .

ceq (zeroD(bn(B1,N1) SRC) and (B = 1st(lhd(SRC bn(B2,N2)))))
     = false if (B1 = not(B)) .

eq (zeroD(bn(B1,N1) SRC) and (N = (s N1)) and 
     (N = (s 2nd(lhd(SRC bn(B2,N2))))))
    = (zeroD(bn(B1,N1) SRC) and (N = (s N1))) .

--
ceq oneD(bn(B1,N1) bn(B2,N2) SRC) = false 
     if ((B1 = B2) and not(N1 = N2)) .
ceq oneD(bn(B1,N1) bn(B2,N2) SRC) = false 
     if (not(B1 = B2) and (N1 = N2)) .

ceq (oneD(bn(B1,N1) bn(B2,N2) SRC) and (N1 = N3)) = false
     if not(N3 = (s N2)) .

eq (oneD(bn(B1,N1) SRC) and (B1 = 1st(rhd(bn(B1,N1) SRC))))
     = zeroD(bn(B1,N1) SRC) .

eq (zeroD(bn(b1,N2) SRC) and oneD(bn(b0,N1) bn(b1,N2) SRC))
     = zeroD(bn(b1,N2) SRC) .
eq (zeroD(bn(b0,N2) SRC) and oneD(bn(b1,N1) bn(b0,N2) SRC))
     = zeroD(bn(b0,N2) SRC) .

eq oneD(bn(B1,N1) bn(B1,N1) SRC) = oneD(bn(B1,N1) SRC) .

eq (zeroD(bn(b1,N2) SRC) and oneD(bn(b0,N1) SRC) and (N1 = s N2))
      = (zeroD(bn(b1,N2) SRC) and (N1 = s N2)) .
eq (zeroD(bn(b0,N2) SRC) and oneD(bn(b1,N1) SRC) and (N1 = s N2))
      = (zeroD(bn(b0,N2) SRC) and (N1 = s N2)) .

eq (oneD(SRC bn(b1,N2)) and oneD(bn(b0,N1) SRC) and (N1 = s N2))
      = (oneD(bn(b0,N1) SRC) and (N1 = s N2)) .
eq (oneD(SRC bn(b0,N2)) and oneD(bn(b1,N1) SRC) and (N1 = s N2))
      = (oneD(bn(b1,N1) SRC) and (N1 = s N2)) .

ceq (zeroD(bn(B2,N2) SRC) and (N1 = (s N2)) 
      and oneD(bn(B1,N1) bn(B2,N2) SRC)) 
   = (zeroD(bn(B2,N2) SRC) and (N1 = (s N2)))
     if not(B1 = B2) .

eq (oneD(bn(B1,N1) bn(B2,N2) SRC) and (N1 = (s N2)))
   = (zeroD(bn(B2,N2) SRC) and (N1 = (s N2))) .

--

ceq (oneD(bn(B1,N1) SRC) and 
     (1st(lhd(SRC bn(B2,N2))) = B1) and
     (2nd(lhd(SRC bn(B2,N2))) = (s N2)))
     = (oneD(bn(B1,N1) SRC) and 
        (1st(lhd(SRC bn(B2,N2))) = B1)) if (B2 = not(B1)) .
ceq (oneD(bn(B1,N1) SRC) and 
     (1st(lhd(SRC bn(B2,N2))) = B1) and
     (2nd(lhd(SRC bn(B2,N2))) = N1))
     = (oneD(bn(B1,N1) SRC) and 
        (1st(lhd(SRC bn(B2,N2))) = B1)) if (B2 = not(B1)) .

ceq (oneD(bn(B1,N1) SRC) and 
     (1st(lhd(SRC bn(B2,N2))) = B2) and
     ((s 2nd(lhd(SRC bn(B2,N2)))) = N1))
     = (oneD(bn(B1,N1) SRC) and 
        (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .

ceq (oneD(bn(B1,N1) SRC) and
     (2nd(lhd(SRC bn(B2,N2))) = N2) and
     (1st(lhd(SRC bn(B2,N2))) = B2))
     = (oneD(bn(B1,N1) SRC) and
        (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .
-- the following equation can be loaded into this module!! 121026
-- strange phenomena!! 
-- ceq (oneD(bn(B1,N1) SRC) and
--     (1st(lhd(SRC bn(B2,N2))) = B2) and
--     (2nd(lhd(SRC bn(B2,N2))) = N2))
--     = (oneD(bn(B1,N1) SRC) and
--        (1st(lhd(SRC bn(B2,N2))) = B2)) if (B2 = not(B1)) .


}

-- properties on RSCH
mod RSCHprop {
pr(RSCH)

-- zero change of elements
pred zeroC : RSch .
eq zeroC(empB) = true .
eq zeroC(B:Bit) = true .
eq zeroC(B1:Bit B2:Bit) = (B1 = B2) .
eq zeroC(B1:Bit RSC:RSch B2:Bit) = ((B1 = B2) and zeroC(B1 RSC)) .

-- at most one change of elements
pred oneC : RSch .
eq oneC(empB) = true .
eq oneC(B:Bit) = true .
eq oneC(B1:Bit B2:Bit) = true .
eq oneC(B1:Bit RSC:RSch B2:Bit) = 
     if (B1 = B2) then zeroC(B1 RSC) else oneC(B1 RSC) fi .

-- proved properties
--> zero-p1
ceq zeroC(B1:Bit B2:Bit RSC:RSch) = false if not(B1 = B2) .
--> zero-p2
eq zeroC(B:Bit B RSC:RSch) = zeroC(B RSC) .
--> zero-p3
eq zeroC(RSC:RSch B:Bit) = zeroC(B RSC) .
--> zero-p4
eq (zeroC(B:Bit RSC:RSch) and zeroC(RSC)) = zeroC(B RSC) .
--> zero-p5
eq (zeroC(B1:Bit RSC:RSch) and (rhd(B1 RSC) = B1)) = (zeroC(B1 RSC)) .

--> one-p1
eq oneC(B1:Bit B1 RSC:RSch) = oneC(B1 RSC) .
--> one-p2
ceq oneC(B1:Bit B2:Bit RSC:RSch) = zeroC(B2 RSC) if not(B1 = B2) .
--> one-p3
eq oneC(RSC:RSch B:Bit) = oneC((not(B)) RSC) .
--> one-p4
eq (zeroC(B1:Bit RSC:RSch) and oneC(B1 RSC)) = zeroC(B1 RSC) .
--> one-p5
eq (oneC(B:Bit RSC:RSch) and oneC(RSC)) = oneC(B RSC) .
--> one-p6
eq (zeroC(RSC:RSch) and oneC(RSC)) = zeroC(RSC) .
--> one-p7
eq (zeroC(B:Bit RSC:RSch) and oneC(RSC)) = zeroC(B RSC) .

--> one-p-11
eq oneC(RSC1:RSch B:Bit B RSC2:RSch) = oneC(RSC1 B RSC2) .
--> one-p-12
eq (oneC(RSC1:RSch B:Bit RSC2:RSch) and oneC(RSC1 RSC2)) = oneC(RSC1 B RSC2) .
}

-- ABP with predicates for invariant formation
mod* ABPprop {
  pr(ABP)
  pr(SRCHprop)
  pr(RSCHprop)
  --
  vars B B1 B2 Bs Br : Bit .
  var N : Nat .
  vars SRC SRC1 SRC2 : SRch .
  var BNP : BNpair .
  var NS : Nseq .
  vars RSC RSC1 RSC2 : RSch .
  var S : State .
  -- (sBit: Bs)(sNum: N)(srCh: SRC)(rBit: Br)(rNums: Nseq)(rsCh: RSC)
  -- p1,p2,... are possible fragments of the invariant predicate

  -- the supposed functionality of ABP protocol
  op p1 : State -> Bool .
  eq[p1]: p1((sBit: Bs)(sNum: N)(rBit: Br)(rNums: NS) S)
             = ((Bs = Br) implies (mk(N) = (N NS))) and
               (not(Bs = Br) implies (mk(N) = NS)) .

  -- supposed property for sBit, sNum, srCh, rBit, and rNums
  ops p2 p1+p2 : State -> Bool .
  eq p1+p2(S) = p1(S) and p2(S) .
  eq[p2]: p2((sBit: Bs)(sNum: N)(srCh: SRC)(rBit: Br)(rNums: NS) S)
          = ((not(SRC = empBN)) implies 
              ((((1st(lhd(SRC)) = 1st(rhd(SRC))) implies
                 (zeroD(SRC) and 
                  (2nd(lhd(SRC)) = 2nd(rhd(SRC))) and
                  ((Bs = 1st(lhd(SRC))) implies (N = 2nd(lhd(SRC)))) and 
                  ((not(Bs = 1st(lhd(SRC)))) implies 
                   ((N = s(2nd(lhd(SRC)))) and (Bs = Br))))))
               and
               ((not(1st(lhd(SRC)) = 1st(rhd(SRC)))) implies
                 ((oneD(SRC) and not(zeroD(SRC))) and
                  (2nd(lhd(SRC)) = s(2nd(rhd(SRC)))) and
                  (Bs = 1st(lhd(SRC))) and 
                  (N = 2nd(lhd(SRC))) and
                  (Bs = Br))))) .

 -- supposed property for rBit, rsCh, and sBit
  ops p3 p1+p3 : State -> Bool .
  eq p1+p3(S) = p1(S) and p3(S) .
  eq[p3]: p3((sBit: Bs)(rBit: Br)(rsCh: RSC) S)
         =  ((not(RSC = empB)) implies 
              (((lhd(RSC) = rhd(RSC)) implies
                 ((not(Br = lhd(RSC))) implies (not(Bs = Br)))))
              and
              ((not(lhd(RSC) = rhd(RSC))) implies
                ((Br = lhd(RSC)) and (not(Bs = Br))))) .

 -- supposed property for rsCh
 ops p4 p1+p4 p2+p3+p4 p2+p4 p3+p4 p1+p3+p4 p1+p2+p3+p4 : State -> Bool .
 eq p1+p4(S) = p1(S) and p4(S) .
 eq p2+p4(S) = p2(S) and p4(S) .
 eq p3+p4(S) = p3(S) and p4(S) .
 eq p2+p3+p4(S) = p2(S) and p3(S) and p4(S) .
 eq p1+p3+p4(S) = p1(S) and p3(S) and p4(S) .
 eq p1+p2+p3+p4(S) = p1(S) and p2(S) and p3(S) and p4(S) .
 eq[p4]: p4((rsCh: RSC) S) =  oneC(RSC) .

 -- supposed property for srCh
 ops p5 p1+p5 p1+p2+p5 p2+p3+p5 p2+p5 p3+p5 p1+p3+p5 p1+p2+p3+p5 : State -> Bool .
 eq p1+p5(S) = p1(S) and p5(S) .
 eq p2+p5(S) = p2(S) and p5(S) .
 eq p1+p2+p5(S) = p1(S) and p2(S) and p5(S) .
 eq p3+p5(S) = p3(S) and p5(S) .
 eq p2+p3+p5(S) = p2(S) and p3(S) and p5(S) .
 eq p1+p3+p5(S) = p1(S) and p3(S) and p5(S) .
 eq p1+p2+p3+p5(S) = p1(S) and p2(S) and p3(S) and p5(S) .
 eq[p5]: p5((srCh: SRC) S) =  oneD(SRC) .

-- ...

}

-- #############################################
-- code for checking all possible cases
-- #############################################

mod CHKcss (TS :: TPP) {
pr(GENcss(INDppp(PPP(TS))))

-- for two level aregument generation
vars B B1 B2 B3 B4 B5 B6 : Bit .
vars N1 N2 N3 N4 N5 N6 : Nat .
vars SRC SRC1 : SRch .
var RSC : RSch .
vars SS SS1 SS2 : SqSq .
-- bit-nat pair generation
op bng_ : SqSq -> VlSq .
eq bng(SS1 || SS2) = (bng SS1) ; (bng SS2) .
eq bng([B1,N1]) = bn(B1,N1) .
-- 2 bit-nat pair channel (RSch) generation
op 2bng_ : SqSq -> VlSq .
eq 2bng(SS1 || SS2) = (2bng SS1) ; (2bng SS2) .
eq 2bng([B1,N1,B2,N2]) = (bn(B1,N1) bn(B2,N2)) .
-- 3 bit-nat pair channel (RSch) generation
op 3bng_ : SqSq -> VlSq .
eq 3bng(SS1 || SS2) = (3bng SS1) ; (3bng SS2) .
eq 3bng([B1,N1,B2,N2,B3,N3]) = (bn(B1,N1) bn(B2,N2) bn(B3,N3)) .
-- bit-nat pair channel (RSch) generation
op 1lpchg_ : SqSq -> VlSq .
eq 1lpchg(SS1 || SS2) = (1lpchg SS1) ; (1lpchg SS2) .
eq 1lpchg([B1,N1,SRC]) = (bn(B1,N1) SRC) .
-- bit-nat pair channel (RSch) generation
op 1rpchg_ : SqSq -> VlSq .
eq 1rpchg(SS1 || SS2) = (1rpchg SS1) ; (1rpchg SS2) .
eq 1rpchg([SRC,B1,N1]) = (SRC bn(B1,N1)) .
-- bit-nat pair channel (RSch) generation
op 1cpchg_ : SqSq -> VlSq .
eq 1cpchg(SS1 || SS2) = (1cpchg SS1) ; (1cpchg SS2) .
eq 1cpchg([SRC,B1,N1,SRC1]) = (SRC bn(B1,N1) SRC1) .
-- bit-nat pair channel (RSch) generation
op pchg_ : SqSq -> VlSq .
eq pchg(SS1 || SS2) = (pchg SS1) ; (pchg SS2) .
eq pchg([B1,N1,SRC,B2,N2]) = (bn(B1,N1) SRC bn(B2,N2)) .
-- 3 bit-nat pair channel (RSch) generation
op 3pchg_ : SqSq -> VlSq .
eq 3pchg(SS1 || SS2) = (3pchg SS1) ; (3pchg SS2) .
eq 3pchg([B1,N1,SRC,B2,N2,B3,N3]) = (bn(B1,N1) SRC bn(B2,N2) bn(B3,N3)) .
-- 3l bit-nat pair channel (RSch) generation
op 3lpchg_ : SqSq -> VlSq .
eq 3lpchg(SS1 || SS2) = (3lpchg SS1) ; (3lpchg SS2) .
eq 3lpchg([B1,N1,B2,N2,SRC,B3,N3]) = (bn(B1,N1) bn(B2,N2) SRC bn(B3,N3)) .
-- 4 bit-nat pair channel (RSch) generation
op 4pchg_ : SqSq -> VlSq .
eq 4pchg(SS1 || SS2) = (4pchg SS1) ; (4pchg SS2) .
eq 4pchg([B1,N1,B2,N2,SRC,B3,N3,B4,N4]) = (bn(B1,N1) bn(B2,N2) SRC bn(B3,N3) bn(B4,N4)) .

-- bit channel (RSch) generation
op bchg_ : SqSq -> VlSq .
eq bchg(SS1 || SS2) = (bchg SS1) ; (bchg SS2) .
eq bchg([B1,RSC,B2]) = (B1 RSC B2) .

-- facts about Bit
eq ((b0 = B) and (b1 = B)) = false .
eq ((Bo:Bool and (B1 = b0)) xor (Bo and (B1 = b1))) = Bo .

-- facts about nat
ceq ((N1 = N2) and (N1 = N3)) = false 
    if not(N2 = N3) .

}

-- (ss ; drSr ; duSr ; rr ; rs ; drRs ; duRs ; sr)

eof

--  (0.000 sec for parse, 2717438 rewrites(205.180 sec), 64516479 matches) with cafeobj149rc6 130101
--  (1.250 sec for parse, 2854107 rewrites(401.330 sec), 79646800 matches) with cafeobj149rc9 130101
open (CHKcss(ABPprop{op pre -> p2,op post -> p2})) .
ops nt1 nt2 nt3 nt4 nt5 : -> NatLt .
op ns : -> Nseq .
op src : -> SRch .
op rsc : -> RSch .
red $ | mmi[(b0),(nt1),
            (empBN ; 
             bng[(b0 ; b1),(nt1 ; nt2)] ; 
	     2bng[(b0 ; b1),(nt1 ; nt2),
                  (b0 ; b1),(nt1 ; nt2 ; nt3)] ;
             3bng[(b0 ; b1),(nt1 ; nt2),
                  (b0 ; b1),(nt1 ; nt2 ; nt3),
                  (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4)] ;
             4pchg[(b0 ; b1),(nt1 ; nt2),
                   (b0 ; b1),(nt1 ; nt2 ; nt3),
                   (empBN ; src),
                   (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4),
                   (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4 ; nt5)]),
            (b0 ; b1),ns,rsc,rr] .
close

--  (0.000 sec for parse, 2685236 rewrites(207.230 sec), 65208241 matches) cafeobj149rc6 130101
--  (1.270 sec for parse, 2826455 rewrites(688.540 sec), 80737416 matches) cafeobj149rc9 130101
open (CHKcss(ABPprop{op pre -> p2,op post -> p2})) .
ops nt1 nt2 nt3 nt4 nt5 : -> NatLt .
op ns : -> Nseq .
op src : -> SRch .
op rsc : -> RSch .
red $ | mmi[(b0),(nt1),
            (empBN ; 
             bng[(b0 ; b1),(nt1 ; nt2)] ; 
	     2bng[(b0 ; b1),(nt1 ; nt2),
                  (b0 ; b1),(nt1 ; nt2 ; nt3)] ;
             3bng[(b0 ; b1),(nt1 ; nt2),
                  (b0 ; b1),(nt1 ; nt2 ; nt3),
                  (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4)] ;
             4pchg[(b0 ; b1),(nt1 ; nt2),
                   (b0 ; b1),(nt1 ; nt2 ; nt3),
                   (empBN ; src),
                   (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4),
                   (b0 ; b1),(nt1 ; nt2 ; nt3 ; nt4 ; nt5)]),
            (b0 ; b1),ns,rsc,drSr] .
close
