-- library

module NIL
{
	signature {
		[ Nil ]
		op	nil	: -> Nil
	}
}

module COLLECTION
(
	X	::	TRIV
)
{
	imports {
		pr(NIL)
	}
	signature {
		[ Nil Elt < Collection ]
		op	_,_	: Collection Collection -> Collection { assoc comm idem id: nil }
		op	_@_	: Elt Collection -> Bool
		op	_\_	: Collection Elt -> Collection
		op	_&_	:	Collection Collection -> Bool { comm }
	}
	axioms {
		vars	X Y	: Elt
		vars	C S T	: Collection
		eq	(C,X = nil)
				=		false .
		eq	X @ nil
				=		false .
		cq	X @ (Y,C)
				=		true
				if	(X = Y) .
		cq	X @ (Y,C)
				=		X @ C
				if	not(X = Y) .
		eq	nil \ X
				=		nil .
		eq	(C,X) \ X
				=		C .
		cq	(C,Y) \ X
				=		C \ X
				if	(not X = Y) .
		eq	nil & C
				=		false .
		eq	S & (C,S)
				=		true .
		cq	S & (C,T)
				=		true
				if	S & T .
		cq	S & (C,T)
				=		S & C
				if	(not S & T) .
	}
}

module LIST
(
	X	::	TRIV
)
{
	imports {
		pr(NIL)
	}
	signature {
		[ Nil Elt < List ]
		op	__	: List List -> List { assoc id: nil }
		op	_@_	: Elt List -> Bool
	}
	axioms {
		vars	X Y	: Elt
		vars	L		: List
		eq	X @ nil
				=		false .
		cq	X @ (Y L)
				=		true
				if	X == Y .
		cq	X @ (Y L)
				=		X @ L
				if	X =/= Y .
	}
}


module QUEUE
(
	X	::	TRIV
)
{
	imports {
		pr(LIST(X) * { sort List -> Queue })
	}
	signature {
		op	enq	: Elt Queue -> Queue
		op	sub	: Elt Queue -> Queue
	}
	axioms {
		vars	X Y	: Elt
		vars	Q		: Queue
		eq	enq(X,Q)
				=		Q X .
		eq	sub(X,nil)
				=		nil .
		cq	sub(X,(Y Q))
				=		Q
				if	X == Y .
		cq	sub(X,(Y Q))
				=		Y sub(X,Q)
				if	X =/= Y .
	}
}

module COMPLEMENT
{
	signature {
		op	~	: Bool -> Bool
	}
	axioms {
		vars	P	: Bool
		eq	~(P)
				=		not (P = true) .
	}
}

-- calculus

module FORMULA
{
	signature {
		[ Bool < Formula ]
		op	_and_			: Formula Formula -> Formula { assoc comm }
		op	_or_			: Formula Formula -> Formula { assoc comm }
		op	not_			: Formula -> Formula
		op	_implies_	: Formula Formula -> Formula
		op	_iff_			: Formula Formula -> Formula
	}
	axioms {
		vars	P Q R	: Formula
		eq	false and P
				=		false .
		eq	true and P
				=		P .
		eq	P and P
				=		P .
		eq	true or P
				=		true .
		eq	false or P
				=		P .
		eq	P or P
				=		P .
		eq	not true
				=		false .
		eq	not false
				=		true .
		eq	not not P
				=		P .
		eq	P implies true
				=		true .
		eq	false implies P
				=		true .
		eq	P implies P
				=		true .
		eq	P iff Q
				=		(P implies Q) and (Q implies P) .
	}
}

make	FORMULAS
(
	COLLECTION(
		FORMULA { sort Elt -> Formula }
	)	*	{
		sort Collection -> Formulas
	}
)

module SEQUENT
{
	imports {
		pr(FORMULAS)
	}
	signature {
		[ Sequent ]
		op	_|-_	: Formulas Formulas -> Sequent
	}
	axioms {
		vars	L R	: Formulas
		eq	true,L |- R
				=		L |- R .
		eq	L |- R,false
				=		L |- R .
		eq	false,L |- R
				=		false |- R .
		eq	L |- R,true
				=		L |- true .
	}
}

make SEQUENTS
(
	COLLECTION(
		SEQUENT { sort Elt -> Sequent }
	)	*	{
		sort Collection -> Sequents
	}
)

module	JUDGEMENT
{
	imports {
		pr(SEQUENTS)
	}
	signature {
		op	hold	: Sequents -> Bool
	}
	axioms {
		vars	P		: Formula
		vars	L R	: Formulas
		vars	S T	: Sequents
		eq	hold(nil |- nil)
				=		false .
		eq	hold(L |- true)
				=		true .
		eq	hold(false |- R)
				=		true .
		eq	hold(P,L |- R,P)
				=		true .
		eq	hold(nil)
				=		true .
		eq	hold(S,T)
				=		hold(S) and hold(T) .
		cq	(P = true)
				=		true
				if	hold(nil |- P) .
	}
}

module INFERENCE
{
	imports {
		ex(JUDGEMENT)
		pr(RWL)
	}
	signature {
		[ Inference ]
		op	antecedent	: Inference -> Sequents
		op	consequent	: Inference -> Sequents
		op	consistent	: Inference -> Bool
	}
	axioms {
		vars	I	: Inference
		cq	consistent(I)
				=		true
				if	antecedent(I) ==> consequent(I) .
		cq	hold(consequent(I))
				=		true
				if	consistent(I)
				and	hold(antecedent(I)) .
	}
}

module LK
{
	imports {
		pr(SEQUENTS)
	}
	axioms {
		vars	P Q	: Formula
		vars	L R	: Formulas
		vars	S T	: Formulas
		rl	(L,P |- R),(S |- P,T)
				=>	L,S |- R,T .
		rl	L,P |- R
				=>	L |- (not P),R .
		rl	(L |- P,R),(S |- Q,T)
				=>	L,S |- (P and Q),R,T .
		rl	L |- P,Q,R
				=>	L |- (P or Q),R .
		rl	L,P |- Q,R
				=>	L |- (P implies Q),R .
		rl	L |- P,R
				=>	L,(not P) |- R .
		rl	L,P,Q |- R
				=>	L,(P and Q) |- R .
		rl	(L,P |- R),(S,Q |- T)
				=>	L,S,(P or Q) |- R,T .
		rl	(L |- P,R),(S,Q |- T)
				=>	L,S,(P implies Q) |- R,T .
	}
}

-- relation

module RELATION
(
	X	::	TRIV
)
{
	imports {
		pr(FORMULA)
	}
	signature {
		[ Relation ]
		op	___	: Elt Relation Elt -> Formula
	}
}

module IRREFLEXIVE
(
	X	::	TRIV,
	R	::	RELATION(X)
)
{
	signature {
		[ Irreflexive < Relation ]
	}
	axioms {
		vars	X	: Elt
		vars	R	: Irreflexive
		eq	(not X R X)
				=		true .
	}
}

module ASYMMETRIC
(
	X	::	TRIV,
	R	::	RELATION(X)
)
{
	signature {
		[ Asymmetric < Relation ]
	}
	axioms {
		vars	X Y	: Elt
		vars	R		: Asymmetric
		cq	not (Y R X)
				=		true
				if	(X R Y = true) .
	}
}

module TRANSITIVE
(
	X	::	TRIV,
	R	::	RELATION(X)
)
{
	imports {
		pr(JUDGEMENT)
	}
	signature {
		[ Transitive < Relation ]
	}
	axioms {
		vars	X Y Z	: Elt
		vars	R			: Transitive
		eq	hold((X R Y),(Y R Z) |- X R Z)
				=		true .
  }
}

module PARTIAL-ORDER
(
	X	::	TRIV,
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	signature {
		[ PartialOrder < Irreflexive Asymmetric Transitive ]
	}
}

module EXPAND
(
	X	::	TRIV,
	R	::	RELATION(X),
	C	::	COLLECTION(X)
)
{
	signature {
		op	___	: Collection Relation Collection -> Formula
	}
	axioms {
		vars	X Y		: Elt
		vars	C D S	: Collection
		vars	R			: Relation
		eq	X R nil
				=		true .
		eq	nil R C
				=		false .
		cq	X R (C,Y)
				=		false
				if	(not X R Y) = true .
		cq	X R (C,Y)
				=		X R C
				if	(X R Y) = true .
		cq	(S,X) R C
				=		true
				if	(X R C) = true .
		cq	(S,X) R C
				=		S R C
				if	(not X R C) = true .
	}	
}

module CEILING
(
	X	::	TRIV,
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R),
	P	::	PARTIAL-ORDER(X,R,I,A,T),
	C	::	COLLECTION(X),
	E	::	EXPAND(X,R,C)
)
{
	signature {
		op	ceiling	: Collection PartialOrder -> Elt
	}
	axioms {
		vars	C	: Collection
		vars	R	: PartialOrder
		cq	ceiling(C,R) @ C
				=		true
				if	(not C = nil) .
		cq	not (C R ceiling(C,R))
				=		true
				if	(not C = nil) .
	}
}

-- proof of the fundamental theorem

module NEGATE
(
	X	::	TRIV,
	R	::	RELATION(X)
)
{
	signature {
		op	!	: Relation -> Relation
	}
	axioms {
		vars	X Y	: Elt
		vars	R		: Relation
		eq	X !(R) Y
				=		(not X R Y) .
	}	
}

module REVERSE
(
	X	::	TRIV,
	Y	::	RELATION(X)
)
{
	signature {
		op	~	: Relation -> Relation
	}
	axioms {
		vars	X Y	: Elt
		vars	R		: Relation
		eq	X ~(R) Y
				=		Y R X .
	}	
}

module BOUND
(
	X	::	TRIV,
	R	::	RELATION(X),
	C	::	COLLECTION(X)
)
{
	imports {
		pr(NEGATE(X,R))
		pr(REVERSE(X,R))
		pr(EXPAND(X,R,C))
	}
	signature {
		op bound	: Collection Relation -> Formula
	}
	axioms {
		vars	C : Collection
		vars	R : Relation
		cq	bound(C,R)
				=		true
				if	C !(~(R)) C .
	}
}

module FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		pr(PARTIAL-ORDER(X,R,I,A,T))
		pr(BOUND(X,R,C))
	}
	signature {
		op	claim	: Collection PartialOrder -> Formula
	}
	axioms {
		vars	C	: Collection
		vars	R	: PartialOrder
		eq	claim(C,R)
				=		(not C = nil) implies bound(C,R) .
	}
}

module ENV-for-PROOF-of-FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		ex(FUNDAMENTAL-THEOREM(X,C,R,I,A,T))
	}
	signature {
		op	c		: -> Collection
		op	c'	: -> Collection
		op	r		: -> PartialOrder
		op	x		: -> Elt
	}
	axioms {
		eq	c'
				=		(c,x) .
	}
}

-- base step
open ENV-for-PROOF-of-FUNDAMENTAL-THEOREM .
eq c = nil .
red claim(c,r) .
close

-- induction step
open ENV-for-PROOF-of-FUNDAMENTAL-THEOREM .
red claim(c,r) .
close

-- case1: c = nil
open ENV-for-PROOF-of-FUNDAMENTAL-THEOREM .
eq c = nil .
red claim(c',r) .
close

-- hypothesis for the proof in induction step
module HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		us(ENV-for-PROOF-of-FUNDAMENTAL-THEOREM(X,C,R,I,A,T))
	}
	signature {
		op	y		: -> Elt
		op	s 	: -> Collection
	}
	axioms {
		eq	c
				=		(s,y) .
		eq	y !(~(r)) s
				=		true .
	}
}

-- confirmation of correctness of the hypothesis
open HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
red not(c = nil) .
red y !(~(r)) c .
close

-- case2: not c = nil
-- case2A: x r y = true
module CASE2A-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		pr(HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM(X,C,R,I,A,T))
		pr(LK)
		pr(INFERENCE)
	}
	axioms {
		eq	hold(nil |- x r y)
				=		true .
	}
}

-- proving that not(s r x)
open CASE2A-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
red (not y r x) = true .
close

open HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
eq s = nil .
red x !(~(r)) s .
close .

open CASE2A-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
op z : -> Elt .
eq z @ s = false .
eq hold(nil |- (not z r y)) = true .
eq x !(~(r)) s = true .
ops q1 q2 q3 : -> Sequent .
eq q1 = (((x r y),(z r x)) |- (z r y)) .
eq q2 = (nil |- x r y) .
eq q3 = (nil |- (not z r y)) .
red hold(q1) .
red hold(q2) .
red hold(q3) .
ops i : -> Inference .
eq antecedent(i) = (q1,q2,q3) .
eq (nil |- (not z r x)) = consequent(i) .
red (not z r x) = true .
red x !(~(r)) (s,z) = true .
close .

-- redefine module CASE2A
module CASE2A-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		pr(HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM(X,C,R,I,A,T))
		pr(LK)
		pr(INFERENCE)
	}
	axioms {
		eq	hold(nil |- x r y)
				=		true .
		eq	x !(~(r)) s
				=		true .
	}
}

open CASE2A-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
red claim(c',r) .
close

-- case2B: x r y = false
module CASE2B-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM
(
	X	::	TRIV,
	C	::	COLLECTION(X),
	R	::	RELATION(X),
	I	::	IRREFLEXIVE(X,R),
	A	::	ASYMMETRIC(X,R),
	T	::	TRANSITIVE(X,R)
)
{
	imports {
		pr(HYPO-for-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM(X,C,R,I,A,T))
	}
	axioms {
		eq	hold(nil |- (not x r y))
				=		true .
	}
}

open CASE2B-of-INDUCTION-STEP-of-PROOF-of-FUNDAMENTAL-THEOREM .
red claim(c',r) .
close

-- framework

module FILTER
{
	signature {
		[ Filter ]
	}
}

module VALUE
{
	signature {
		[ Value ]
	}
}

module CONTAINER
{
	signature {
		[ Container ]
	}
}

module STATE
{
	imports {
		ex(CONTAINER)
	}
	signature {
		[ State < Container ]
	}
}

module OBSERVATION
{
	imports {
		pr(CONTAINER)
		pr(FILTER)
		ex(VALUE)
	}
	signature {
		op	prj	: Filter Container -> Value
	}
}

-- support sorts

module NONE
{
	signature {
		[ None ]
		op	none	: -> None
	}
}

module PROCESS
{
	imports {
		pr(NONE)
	}
	signature {
		[ None < Process ]
	}
}

-- instantiation of parameterized modules

make PROCESSES
(
	COLLECTION(
		PROCESS { sort Elt -> Process }
	) * {
		sort Collection -> Processes
	}
)

make SCHEDULE
(
	QUEUE(
		PROCESS { sort Elt -> Process }
	) * {
		sort Queue -> Schedule
	}
)

make PRECEDENCE
(
	RELATION(
		PROCESS { sort Elt -> Process }
	) * {
		sort Relation -> Precedence
	}
)

make IRREFLEXIVE-PRECEDENCE
(
	IRREFLEXIVE(
		PROCESS { sort Elt -> Process },
		PRECEDENCE { sort Relation -> Precedence }
	)
)

make ASYMMETRIC-PRECEDENCE
(
	ASYMMETRIC(
		PROCESS { sort Elt -> Process },
		PRECEDENCE { sort Relation -> Precedence }
	)
)

make TRANSITIVE-PRECEDENCE
(
	TRANSITIVE(
		PROCESS { sort Elt -> Process },
		PRECEDENCE { sort Relation -> Precedence }
	)
)

make PRIORITY
(
	PARTIAL-ORDER(
		PROCESS { sort Elt -> Process },
		PRECEDENCE { sort Relation -> Precedence },
		IRREFLEXIVE-PRECEDENCE,
		ASYMMETRIC-PRECEDENCE,
		TRANSITIVE-PRECEDENCE
	) * {
		sort PartialOrder -> Priority
	}
)

-- filters and observations

module FILTER4PROCESS
{
	imports {
		ex(FILTER)
	}
	signature {
		[ Filter4Process < Filter ]
	}
}

module OBSERVATION4PROCESS
{
	imports {
		ex(OBSERVATION)
		pr(FILTER4PROCESS)
		pr(PROCESS)
	}
	signature {
		[ Process < Value ]
		op	prj	: Filter4Process Container -> Process
	}
}

module FILTER4PROCESSES
{
	imports {
		ex(FILTER)
	}
	signature {
		[ Filter4Processes < Filter ]
	}
}

module OBSERVATION4PROCESSES
{
	imports {
		ex(OBSERVATION)
		pr(FILTER4PROCESSES)
		pr(PROCESSES)
	}
	signature {
		[ Processes < Value ]
		op	prj	: Filter4Processes Container -> Processes
	}
}

module FILTER4SCHEDULE
{
	imports {
		ex(FILTER)
	}
	signature {
		[ Filter4Schedule < Filter ]
	}
}

module OBSERVATION4SCHEDULE
{
	imports {
		ex(OBSERVATION)
		pr(FILTER4SCHEDULE)
		pr(SCHEDULE)
	}
	signature {
		[ Schedule < Value ]
		op	prj	: Filter4Schedule Container -> Schedule
	}
}

module FILTER4PRECEDENCE
{
	imports {
		ex(FILTER)
	}
	signature {
		[ Filter4Precedence < Filter ]
	}
}

module OBSERVATION4PRECEDENCE
{
	imports {
		ex(OBSERVATION)
		pr(FILTER4PRECEDENCE)
		pr(PRECEDENCE)
	}
	signature {
		[ Precedence < Value ]
		op	prj	: Filter4Precedence Container -> Precedence
	}
}

module FILTER4PRIORITY
{
	imports {
		ex(FILTER)
	}
	signature {
		[ Filter4Priority < Filter ]
	}
}

module OBSERVATION4PRIORITY
{
	imports {
		ex(OBSERVATION)
		pr(FILTER4PRIORITY)
		pr(PRIORITY)
	}
	signature {
		[ Priority < Value ]
		op	prj	: Filter4Priority Container -> Priority
	}
}

-- scheduling

module ACTIVE
{
	imports {
		ex(OBSERVATION4PROCESSES)
	}
	signature {
		op	active	: -> Filter4Processes
	}
}

module ROLL
{
	imports {
		ex(OBSERVATION4SCHEDULE)
	}
	signature {
		op	roll	: -> Filter4Schedule
	}
}

make EXPAND-PRECEDENCE
(
	EXPAND(
		PROCESS { sort Elt -> Process },
		PRECEDENCE { sort Relation -> Precedence },
		PROCESSES { sort Collection -> Processes }
	)
)

module CEILING-PROCESS
{
	imports {
		pr(
			CEILING(
				PROCESS { sort Elt -> Process },
				PRECEDENCE { sort Relation -> Precedence },
				IRREFLEXIVE-PRECEDENCE,
				ASYMMETRIC-PRECEDENCE,
				TRANSITIVE-PRECEDENCE,
				PRIORITY { sort PartialOrder -> Priority },
				PROCESSES { sort Collection -> Processes },
				EXPAND-PRECEDENCE
			)
		)
	}
	axioms {
		vars	R	: Priority
		eq	ceiling(nil,R)
				=		none .
	}
}

module CRITERION
{
  imports {
    pr(STATE)
    ex(PRIORITY)
  }
  signature {
    op criterion : State -> Priority
  }
}

module CURRENT
{
	imports {
		pr(ACTIVE)
		pr(CRITERION)
		pr(CEILING-PROCESS)
	}
	signature {
		op	current	: State -> Process
	}
	axioms {
		vars	C	: State
		cq	current(C)
				=		none
				if	(prj(active,C) = nil) .
		cq	current(C)
				=		ceiling(prj(active,C),criterion(C))
				if	(not prj(active,C) = nil) .
	}
}

-- proof of priority-inversion-freeness

module PRIORITY-INVERSION-FREE
{
	imports {
		pr(CURRENT)
	}
	signature {
		op	PIF	: State -> Formula
	}
	axioms {
		vars	C	: State
		eq	PIF(C)
				=		not (prj(active,C) criterion(C) current(C)) .
	}
}

open PRIORITY-INVERSION-FREE .
op c : -> State .
eq prj(active,c) = nil .
red PIF(c) .
close

open PRIORITY-INVERSION-FREE .
op c : -> State .
eq (not prj(active,c) = nil) = true .
red PIF(c) .
close

-- definition of priority ceiling protocol

module COMPARE
{
	imports {
		pr(PRIORITY)
	}
	signature {
		op	comp		: Process Process Priority -> Formula
		op	incomp	: Process Process Priority -> Formula
	}
	axioms {
		vars	P Q	: Process
		vars	R		: Priority
		cq	hold(nil |- comp(P,Q,R))
				=		true
				if	((P R Q = true) or (Q R P = true)) .
		cq	hold(nil |- incomp(P,Q,R))
				=		true
				if	(((not P R Q) = true) and ((not Q R P) = true)) .
	}
}

module PRIOR
{
	imports {
		ex(COMPARE)
	}
	signature {
		op	prior	: -> Priority
	}
	axioms {
		vars P Q R	: Process
		eq	hold(incomp(P,Q,prior),(R prior P) |- (R prior Q))
				=		true .
		eq	hold(incomp(P,Q,prior),(Q prior R) |- (P prior R))
				=		true .
		eq	hold(incomp(P,Q,prior),incomp(Q,R,prior) |- incomp(P,R,prior))
				=		true .
	}
}

module EARLIER
{
	imports {
		pr(PRECEDENCE)
		pr(PROCESSES)
		pr(STATE)
		pr(ROLL)
	}
	signature {
		op	earlier	: Schedule -> Precedence
		op	earlier	: State -> Precedence
	}
	axioms {
		vars	P Q R	: Process
		vars	L			: Schedule
		vars	C			: State
		eq	P earlier(nil) Q
				=		false .
		eq	P earlier(L) P
				=		false .
		cq	P earlier(P L) Q
				=		true
				if	(not P = Q) = true .
		cq	P earlier(Q L) Q
				=		false
				if	(not P = Q) = true .
		cq	P earlier(R L) Q
				=		P earlier(L) Q
				if	(not R @ (P,Q)) .
		eq	P earlier(C) Q
				=		P earlier(prj(roll,C)) Q .
	}
}

-- proof of irreflexivity of eariler
open EARLIER .
op l : -> Schedule .
op p : -> Process .
red not p earlier(l) p .
close

-- proof of asymmetricity of earlier
open EARLIER .
ops p q r : -> Process .
eq (not p = q) = true .
eq (not r @ (p,q)) = true .
red (not (p earlier(nil) q and q earlier(nil) p)) .
op l : -> Schedule .
eq (not (p earlier(l) q and q earlier(l) p)) = true .
red (not (p earlier(p l) q and q earlier(p l) p)) .
red (not (p earlier(q l) q and q earlier(q l) p)) .
red (not (p earlier(r l) q and q earlier(r l) p)) .
close

-- proof of transitivity of earlier
open EARLIER .
ops p q r : -> Process .
eq (not p = q) = true .
eq (not r @ (p,q)) = true .
red ((p earlier(nil) q and q earlier(nil) r) implies (p earlier(nil) r)) = true .
op l : -> Schedule .
eq ((p earlier(l) q and q earlier(l) r) implies (p earlier(l) r)) = true .
red ((p earlier(p l) q and q earlier(p l) r) implies (p earlier(p l) r)) .
red ((p earlier(q l) q and q earlier(q l) r) implies (p earlier(q l) r)) .
red ((p earlier(r l) q and q earlier(r l) r) implies (p earlier(r l) r)) .
close

module EARLIER
{
	imports {
		pr(PRIORITY)
		pr(PROCESSES)
		pr(STATE)
		pr(ROLL)
	}
	signature {
		op	earlier	: Schedule -> Priority
		op	earlier	: State -> Priority
	}
	axioms {
		vars	P Q R	: Process
		vars	L			: Schedule
		vars	C			: State
		eq	P earlier(nil) Q
				=		false .
		eq	P earlier(L) P
				=		false .
		cq	P earlier(P L) Q
				=		true
				if	(not P = Q) = true .
		cq	P earlier(Q L) Q
				=		false
				if	(not P = Q) = true .
		cq	P earlier(R L) Q
				=		P earlier(L) Q
				if	(not R @ (P,Q)) .
		eq	P earlier(C) Q
				=		P earlier(prj(roll,C)) Q .
	}
}

module CEILING-PRIORITY
{
	imports {
		ex(PROCESS)
		pr(STATE)
	}
	signature {
		op cp : Process State -> Process
	}
}

module PCP
{
	imports {
		pr(PRIOR)
		pr(EARLIER)
		pr(CEILING-PRIORITY)
	}
	signature {
		op	pcp	: State -> Precedence
	}
	axioms {
		vars	P Q	: Process
		vars	C		: State
		cq	P pcp(C) Q
				=		true
				if	(cp(P,C) prior cp(Q,C) = true) .
		cq	P pcp(C) Q
				=		false
				if	(cp(Q,C) prior cp(P,C) = true) .
		cq	P pcp(C) Q
				=		P earlier(C) Q
				if	(incomp(cp(P,C),cp(Q,C),prior) = true) .
	}
}

-- proving that pcp(c) is a partial order
module ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP
{
	imports {
		pr(PCP)
	}
	signature {
		ops	p q r	: -> Process
		ops	c			: -> State	
	}
}

-- proof of irreflexivity of pcp(c)
open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP .
red not p pcp(c) p .
close

-- proof of asymmetricity of pcp(c)
open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP .
eq cp(p,c) prior cp(q,c) = true .
red not (p pcp(c) q and q pcp(c) p) .
close

open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP .
eq incomp(cp(p,c),cp(q,c),prior) = true .
eq incomp(cp(q,c),cp(p,c),prior) = true .
eq p earlier(prj(roll,c)) q = true .
red not (p pcp(c) q and q pcp(c) p) .
close

-- proof of transitivity of pcp(c)
open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP + LK + INFERENCE .
ops cp1 cp2 cp3 : -> Process .
eq cp1 = cp(p,c) .
eq cp2 = cp(q,c) .
eq cp3 = cp(r,c) .
ops q1 q2 q3 : -> Sequent .
eq q1 = (((cp1 prior cp2),(cp2 prior cp3)) |- (cp1 prior cp3)) .
eq q2 = (nil |- cp1 prior cp2) .
eq q3 = (nil |- cp2 prior cp3) .
eq hold(nil |- cp(p,c) prior cp(q,c)) = true .
eq hold(nil |- cp(q,c) prior cp(r,c)) = true .
ops i : -> Inference .
eq antecedent(i) = (q1,q2,q3) .
eq (nil |- (cp(p,c) prior cp(r,c))) = consequent(i) .
red (cp(p,c) prior cp(r,c)) = true .
close

open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP + LK + INFERENCE .
ops p1 p2 p3 : -> Formula .
eq p1 = incomp(cp(p,c),cp(q,c),prior) .
eq p2 = incomp(cp(q,c),cp(r,c),prior) .
eq p3 = incomp(cp(p,c),cp(r,c),prior) .
ops q1 q2 q3 : -> Sequent .
eq q1 = ((p1,p2) |- p3) .
eq q2 = (nil |- p1) .
eq q3 = (nil |- p2) .
eq hold(nil |- incomp(cp(p,c),cp(q,c),prior)) = true .
eq hold(nil |- incomp(cp(q,c),cp(r,c),prior)) = true .
ops i : -> Inference .
eq antecedent(i) = (q1,q2,q3) .
eq (nil |- incomp(cp(p,c),cp(r,c),prior)) = consequent(i) .
red p1 = true .
red p2 = true .
red p3 = true .

ops p4 p5 p6 : -> Formula .
eq p4 = (p earlier(c) q) .
eq p5 = (q earlier(c) r) .
eq p6 = (p earlier(c) r) .
ops q4 q5 q6 : -> Sequent .
eq q4 = ((p4,p5) |- p6) .
eq q5 = (nil |- p4) .
eq q6 = (nil |- p5) .
eq hold(nil |- (p earlier(prj(roll,c)) q)) = true .
eq hold(nil |- (q earlier(prj(roll,c)) r)) = true .
op j : -> Inference .
eq antecedent(j) = (q4,q5,q6) .
eq (nil |- (p earlier(prj(roll,c)) r)) = consequent(j) .
red p4 = true .
red p5 = true .
red p6 = true .

red (p pcp(c) q) = true .
red (q pcp(c) r) = true .
red (p pcp(c) r) = true .
close

open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP + LK + INFERENCE .
ops p1 p2 p3 : -> Formula .
eq p1 = (cp(p,c) prior cp(q,c)) .
eq p2 = incomp(cp(q,c),cp(r,c),prior) .
eq p3 = (cp(p,c) prior cp(r,c)) .
ops q1 q2 q3 : -> Sequent .
eq q1 = ((p1,p2) |- p3) .
eq q2 = (nil |- p1) .
eq q3 = (nil |- p2) .
eq hold(nil |- cp(p,c) prior cp(q,c)) = true .
eq hold(nil |- incomp(cp(q,c),cp(r,c),prior)) = true .
eq (q earlier(c) r) = true .
ops i : -> Inference .
eq antecedent(i) = (q1,q2,q3) .
eq (nil |- cp(p,c) prior cp(r,c)) = consequent(i) .
red p1 = true .
red p2 = true .
red p3 = true .
red (p pcp(c) q) = true .
red (q pcp(c) r) = true .
red (p pcp(c) r) = true .
close

open ENV-for-PROOF-of-PARTIALLY-ORDEREDNESS-of-PCP + LK + INFERENCE .
ops p1 p2 p3 : -> Formula .
eq p1 = incomp(cp(p,c),cp(q,c),prior) .
eq p2 = (cp(q,c) prior cp(r,c)) .
eq p3 = (cp(p,c) prior cp(r,c)) .
ops q1 q2 q3 : -> Sequent .
eq q1 = ((p1,p2) |- p3) .
eq q2 = (nil |- p1) .
eq q3 = (nil |- p2) .
eq hold(nil |- incomp(cp(p,c),cp(q,c),prior)) = true .
eq (p earlier(c) q) = true .
eq hold(nil |- cp(q,c) prior cp(r,c)) = true .
ops i : -> Inference .
eq antecedent(i) = (q1,q2,q3) .
eq (nil |- cp(p,c) prior cp(r,c)) = consequent(i) .
red p1 = true .
red p2 = true .
red p3 = true .
red (p pcp(c) q) = true .
red (q pcp(c) r) = true .
red (p pcp(c) r) = true .
close

-- redefine pcp
module PCP
{
	imports {
		pr(PRIOR)
		pr(EARLIER)
		pr(CEILING-PRIORITY)
	}
	signature {
		op	pcp	: State -> Priority
	}
	axioms {
		vars	P Q	: Process
		vars	C		: State
		cq	P pcp(C) Q
				=		true
				if	(cp(P,C) prior cp(Q,C) = true) .
		cq	P pcp(C) Q
				=		false
				if	(cp(Q,C) prior cp(P,C) = true) .
		cq	P pcp(C) Q
				=		P earlier(C) Q
				if	(incomp(cp(P,C),cp(Q,C),prior) = true) .
	}
}

-- confirmation of priority inversion freeness for pcp
module PRIORITY-INVERSION-FREE-for-PCP
{
	imports {
		us(PRIORITY-INVERSION-FREE)
		pr(PCP)
	}
	axioms {
		vars	C	: State
		eq	criterion(C)
				=		pcp(C) .
	}
}

open PRIORITY-INVERSION-FREE-for-PCP .
op c : -> State .
eq prj(active,c) = nil .
red PIF(c) .
close

open PRIORITY-INVERSION-FREE-for-PCP .
op c : -> State .
eq (not prj(active,c) = nil) = true .
red PIF(c) .
close

-- framework for specifying state transition

module ACTION
{
	signature {
		[ Action ]
	}
}

module DEPENDENCY
{
	imports {
		pr(FILTER)
		pr(ACTION)
	}
	signature {
		op	depend	: Filter Action -> Bool
	}
}

module TRANSITION
{
	imports {
		pr(COMPLEMENT)
		pr(STATE)
		us(OBSERVATION)
		pr(DEPENDENCY)
	}
	signature {
		op	act	: Action State -> State
		op	pre	: Action State -> Bool
	}
	axioms {
		vars	C	: State
		vars	A	: Action
		vars	F	: Filter
		cq	act(A,C)
				=		C
				if	~(pre(A,C)) .
		cq	prj(F,act(A,C))
				=		prj(F,C)
				if	~(depend(F,A)) .
  }
}

-- state transition

module ENABLE
{
	imports {
		ex(TRANSITION)
		pr(ACTIVE)
		pr(ROLL)
	}
	signature {
		[ Enable < Action ]
		op joined : Enable -> Process
	}
	axioms {
		vars	C	: State
		vars	F	: Enable
		cq	prj(active,act(F,C))
				=		(joined(F),prj(active,C))
				if	pre(F,C) .
		cq	prj(roll,act(F,C))
				=		enq(joined(F),prj(roll,C))
				if	pre(F,C) .
		eq	depend(active,F)
				=		true .
		eq	depend(roll,F)
				=		true .
	}
}

module DISABLE
{
	imports {
		ex(TRANSITION)
		pr(ACTIVE)
		pr(ROLL)
	}
	signature {
		[ Disable < Action ]
		op	quit	: Disable -> Process
	}
	axioms {
		vars	C	: State
		vars	F	: Disable
		cq	prj(active,act(F,C))
				=		prj(active,C) \ quit(F)
				if	pre(F,C) .
		cq	prj(roll,act(F,C))
				=		sub(quit(F),prj(roll,C))
				if	pre(F,C) .
		eq	depend(active,F)
				=		true .
		eq	depend(roll,F)
				=		true .
	}
}

